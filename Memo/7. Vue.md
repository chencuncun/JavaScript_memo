# Vue学习笔记
## 1. Vue实例传入的options
### 1.1 选项
- `el`
  - 类型：`string`|`HTMLElement`
  - 作用：决定之后`Vue`实例会管理哪一个`DOM`
- `data`
  - 类型：`Object`|`Function`(组件当中`data`必须是一个函数)
  - 作用：`Vue`实例对应的数据对象
- `methods`
  - 类型：`{[key:string]:Function}`
  - 作用：定义属于`Vue`的一些方法，可以在其他地方调用，也可以在指令中使用
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mvvm概念</title>
</head>
<body>
    <div id="app">
        <h2>当前计数：{{counter}}</h2>
        <!-- <button v-on:click="counter++">➕</button> -->
        <!-- <button v-on:click="counter--">➖</button> -->

        <!-- <button v-on:click="add">+</button> -->
        <!-- <button v-on:click="sub">-</button> -->

        <!-- 以上被注释的代码可以简写成如下代码 -->
        <!-- view:DOM-->
        <button @click="add">+</button>
        <button @click="sub">-</button>

    </div>
    <script src="../js/vue.js"></script>
    <script>
        // Model
        const obj = {
            counter: 0
        }
        //viewmodel
        const app = new Vue({
            el: '#app',
            data: obj,
            methods: {
                add: function () {
                    console.log('add被执行'),
                        this.counter++
                },
                sub: function () {
                    console.log('sub被执行'),
                        this.counter--
                }
            }
        })
    </script>
</body>
</html>
```
## 2. 模版语法
### 2.1 mustache语法
不仅仅可以直接写变量，也可以写简单的表达式 <br/>
```
<body>
    <div id="app">
        {{message}}, {{lastName + firstName}}!
        <div>{{counter * 2}}</div>
    </div>

    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: '你好',
                firstName: '银河',
                lastName: '李',
                counter: 100
            }
        })
    </script>
</body>

实行结果：
你好, 李银河!
200
```
### 2.2 `v-once`指令
- 该指令后面不需要跟任何表达式
- 该指令表示元素和组件值渲染一次，不会随着数据的改变而改变
```
<body>
    <div id="app">
        <h2>{{message}}</h2> 
        <h2 v-once>{{message}}</h2>
    </div>
    <script src="../js/vue.js"></script> 
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: 'hello'
            }
        })
    </script>
</body>

实行结果：
当在控制台改变app.message的内容时，
含有v-once的元素里的内容不会被改变。
```
### 2.3 `v-html`指令
在某些情况下，我们从服务器请求到的数据本身就是一个HTML代码。<br/>
- 如果我们直接通过`{{}}`来输出，会将HTML代码也一起输出
- 但是我们可能希望的是按照HTML格式进行解析，并且显示对应的内容
上述情况可以使用`v-html`指令
- 该指令后面往往会跟上一个`string`类型
- 会将`string`的`html`解析出来并且进行渲染
```
<body>
    <div id="app">
        <h2>{{url}}</h2>
        <h2 v-html='url'></h2>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                url: '<a href="https://www.google.co.jp/">google</a>'
            }
        })
    </script>
</body>

实行结果：
<a href="https://www.google.co.jp/">google</a>
google
```
### 2.4 `v-text`指令(一般不使用)
```
<body>
    <div id="app">
        <h2>{{message}}</h2>
        <h2 v-text="message"></h2>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: '你好'
            }
        })
    </script>
</body>

实行结果：
你好
你好
```
### 2.5 `v-pre`指令
用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。
```
<body>
    <div id="app">
        <h2>{{message}}</h2>
        <h2 v-pre>{{message}}</h2>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: '你好'
            }
        })
    </script>
</body>

实行结果：
你好
{{message}}
```
### 2.6 `v-cloak`指令
在某些情况下，我们浏览器可能会直接显示出未编译的Mustache标签。<br/>
```
<head>
    <style>
        [v-cloak] {
            display: none;
        }
    </style> 
</head>
<body>
    <div id="app" v-cloak>
        {{message}}
    </div>
    <script src="../js/vue.js"></script>
    <script>
        //在vue解析之前，div中有一个属性v-cloak
        //在vue解析之后，div中没有属性v-cloak
        setTimeout(function () {
            const app = new Vue({
                el: '#app',
                data: {
                    message: '你好'
                }
            })
        })
    </script>
</body>
```
## 3. `v-bind`指令
### 3.1 基本使用
#### 3.1.1 介绍
以上我们学习的指令主要作用是将值插入到我们模版的内容当中。<br/>
但是，除了内容需要动态来决定外，某些属性我们也希望动态来绑定。<br/>
比如：<br/>
- 动态绑定`a`元素的`href`属性
- 动态绑定`img`元素的`src`属性
此时，我们可以使用`v-bind`指令 <br/>
- 作用：动态绑定属性
- 缩写：`:`
- 预期：`any(with argument)`|`Object(without argument)`
- 参数：`attrOrProp(optional)`
```
<body>
    <div id="app">
        <img v-bind:src="imgUrl" alt="">
        <a v-bind:href="link">Vuejs官方网站</a>
    </div>
    <script src="../js/vue.js"></script>
    <script>

        const app = new Vue({
            el: '#app',
            data: {
                message: '你好',
                imgUrl: 'https://cn.vuejs.org/images/logo.png',
                link:'https://cn.vuejs.org/'
            }
        })
    </script>
</body>
```
#### 3.1.2 `v-bind`语法糖
v-bind有一个对应的语法糖，也就是简写方式。<br/>
在开发中，我们通常会使用语法糖的形式，因为这样更加简介。<br/>
```
<img :src="imgUrl" alt="">
<a :href="link">Vuejs官方网站</a>
```
### 3.2 `v-bind`动态绑定`class`(对象语法)
- 绑定方式：对象语法
  - 对象语法的含义是`:class`后面跟的是一个对象
- 对象语法有下面这些用法
  - 用法一：直接通过`{}`绑定一个类
    - `<h2 :class="{'active':isActive}">Hello World</h2>`
  - 用法二：也可以通过判断，传入多个值
    - `<h2 :class="{'active':isActive,'line':isLine}">Hello World</h2>`
  - 用法三：和普通的类同时存在，并不冲突
    - `<h2 class="title" :class="{'active':isActive,'line':isLine}">Hello World</h2>`
  - 用法四：如果过于负责，可以放在一个`methods`或是`computed`中
    - `<h2 class="title" :class="classes">Hello World</h2>`
    - 注：`classes`是一个计算属性
```
<head>
    <title>v-bind动态绑定class对象语法</title>
    <style>
        .active {
            color: red;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- <h2 :class="{类名1:boolean,类名2:boolean}"></h2> -->
        <h2 :class="{active:isActive,line:isLine}">{{message}}</h2>
    </div>
    <script src="../js/vue.js"></script>
    <script>

        const app = new Vue({
            el: '#app',
            data: {
                message: '你好',
                isActive: true,
                isLine: true
            }
        })
    </script>
</body>

实行结果：
如果在控制台输入app.isActive=false，
则h2元素中的active class将不会被加进去
```
```
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>v-bind指令的使用</title>
    <style>
        .active {
            color: red;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- <h2 :class="{类名1:boolean,类名2:boolean}"></h2> -->
        <h2 :class="{active:isActive,line:isLine}">{{message}}</h2>
        <h2 :class="getClasses()">{{message}}</h2>
        <button v-on:click="btnClick">按钮</button>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app', 
            data: {
                message: '你好',
                isActive: true,
                isLine: true
            },
            methods:{
                btnClick:function(){
                    this.isActive = !this.isActive
                },
                getClasses:function(){
                    return {active:this.isActive,line:this.isLine}
                }
            }
        })
    </script>
</body>

实行结果：
你好
你好
按钮
```
### 3.3 `v-bind`动态绑定`class`(数组语法)
```
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>v-bind动态绑定class(数组语法)</title>
    <style>
        .active {
            color: red;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- <h2 :class="{类名1:boolean,类名2:boolean}"></h2> -->
        <h2 :class="[active,line]">{{message}}</h2>
        <h2 :class="getClasses()">{{message}}</h2>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: '你好',
                active: 'aaa',
                line: 'bbb'
            },
            methods: {
                getClasses: function () {
                    return [this.active,this.line]
                }
            }
        })
    </script>
</body>
```
 ### 3.4 `v-bind`绑定style
 我们可以利用`v-bind:style`来绑定一些CSS内联样式。<br/>
 在写CSS属性名的时候，比如`font-size` <br/>
 - 我们可以使用驼峰式：`fontSize`
 - 或短横线分隔：`'font-size'`
 绑定class有两种方式：<br/>
 - 绑定方式一：对象语法
```
:style="{color:currentColor,fontSize:fontsize+'px'}"
```
`style`后面跟的是一个对象类型 <br/>
- 对象的`key`是CSS属性名称
- 对象的`value`是具体赋的值，值可以来自`data`中的属性
```
<body>
    <div id="app">

        <!-- <h2 :style="{属性名:属性值}">{{message}}</h2> -->
        <!-- '50px'必须加上单引号，否则是当作一个变量去解析 -->
        <!-- <h2 :style="{fontSize:'50px'}">{{message}}</h2> -->

        <!-- finalSize当成一个变量使用 -->
        <!-- <h2 :style="{fontSize:finalSize,color:finalColor}">{{message}}</h2> -->

        <h2 :style="getStyles()">{{message}}</h2>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: '你好',
                finalSize: '50px',
                finalColor: 'red'
            },
            methods:{
                getStyles:function(){
                    return {fontSize:this.finalSize,color:this.finalColor}
                }
            }
        })
    </script>
</body>
```
- 绑定方式二：数组语法
```
<div v-bind:style="[baseStyle,overridingStyles]"></div>
```
sytle后面跟的是一个数组类型 <br/>
- 多个值以`,`分割即可
```
<body>
    <div id="app">
        <h2 :style="[baseStyle1,baseStyle2]">{{message}}</h2>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: '你好',
                baseStyle1: {backgroundColor:'red'},
                baseStyle2: {fontSize:'100px'}
            }
        })
    </script>
</body>
```
## 4. 计算属性
### 4.1 基本使用
```
<body>
    <div id="app">
        <h2>{{fullName}}</h2>
        <!-- <h2>{{fullName()}}</h2> -->
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                firstName: 'Amy',
                lastName: 'James'
            },
            //计算属性
            computed: {
                fullName: function () {
                    return this.firstName + ' ' + this.lastName
                }
            },
            // methods: {
            //     fullName: function () {
            //         return this.firstName + ' ' + this.lastName
            //     }
            // }
        })
    </script>
</body>
```
### 4.2 复杂操作
```
<body>
    <div id="app">
        <h2>总价格：{{totalPrice}}</h2>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                books: [
                    { id: 110, name: 'Unix编程艺术', price: 100 },
                    { id: 111, name: '代码大全', price: 130 },
                    { id: 112, name: '深入理解计算机原理', price: 140 },
                    { id: 113, name: '现代操作系统', price: 100 }
                ]
            },
            //计算属性
            computed: {
                totalPrice: function () {
                    let sum = 0
                    for (let i = 0; i < this.books.length; i++) {
                        sum += this.books[i].price;
                    }
                    return sum
                    // return this.books[0].price + this.books[1].price + this.books[2].price + this.books[3].price;
                }
            },
        })
    </script>
</body>
```
### 4.3 计算属性`setter`和`getter`
每个计算属性都包含一个`getter`和一个`setter`。<br/>
```
<body>
    <div id="app">{{fullName}}</div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                firstName: 'Kobe',
                lastName: 'Bryant'
            },
            computed: {
                // fullName: function () {
                //     return this.firstName + ' ' + this.lastName
                // }
                fullName: {
                    //计算属性一般是没有set方法，只读属性
                    // set: function () {

                    // },
                    get: function () {
                        return this.firstName + ' ' + this.lastName
                    }
                }
            }
        })
    </script>
</body>
```
```
<body>
    <div id="app">{{fullName}}</div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                firstName: 'Kobe',
                lastName: 'Bryant'
            },
            computed: {
                // fullName: function () {
                //     return this.firstName + ' ' + this.lastName
                // }
                fullName: {
                    //计算属性一般是没有set方法，只读属性
                    set: function (newValue) {
                        const names = newValue.split(' ');
                        this.firstName = names[0];
                        this.lastName = names[1];
                    },
                    get: function () {
                        return this.firstName + ' ' + this.lastName
                    }
                }
            }
        })
    </script>
</body>

实行结果：
在控制台输入新的名字，则旧名字将会被覆盖掉
```
### 4.4 计算属性`computed`和方法`methods`的对比
`methods`和`computed`看起来都可以实现我们的功能，但是我们一般会首先考虑使用计算属性。 <br/>
原因：计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。
## 5. 块级作用域
### 5.1 let/var
ES5中的var是没有块级作用域的，ES6中的let是有块级作用域的(比如：if/for)
```
<body>
    <button>按钮1</button>
    <button>按钮2</button>
    <button>按钮3</button>
    <button>按钮4</button>
    <button>按钮5</button>
    <script src="../js/vue.js"></script>
    <script>
        var btns = document.getElementsByTagName('button');
        // ES5之前因为if和for都没有块级作用域的概念，所以在很多时候，
        //我们必须借助与function的作用域来解决外面变量的问题
        /*
        for (var i = 0; i < btns.length; i++) {
            (function (num) {
                btns[i].addEventListener('click', function () {
                    alert('第' + (num+1) + '个按钮被点击');
                })
            })(i)
        }
        */
        //ES6中，加入了let，let是有if和for的块级作用域的。
        for (let i = 0; i < btns.length; i++) {
            btns[i].addEventListener('click', function () {
                alert('第' + (i + 1) + '个按钮被点击')
            })
        } 
    </script>
</body>
```
### 5.2 `const`的使用和注意点
在很多语言中已经存在，比如C/C++中，主要的作用是将某个变量修饰为常量。<br/>
在JavaScript中也是如此，使用`const`修饰的标识符为常量，不可以再次负值。<br/>
当我们修饰的标识符不会被再次赋值时，就可以使用`const`来保证数据的安全性。<br/>
在ES6开发中，优先使用`const`，只有需要改变某一个标识符的时候才使用`let`。<br/>
`const`的注意点：<br/>
- 注意点一：一旦给`const`赋值，则不能修改
```
const a = 20;
a = 30; //错误：不可以修改
```
- 注意点二：在使用`const`定义标识符，必须进行赋值
```
const name; //错误：const修饰的标识符必须赋值
```
- 注意点三：常量的含义是指向的对象不能修改，但是可以改变对象内部的属性
```
<script>
        const obj = {
            name: 'why',
            age: 18,
            height: 188
        }

        console.log(obj);

        obj.name = 'kobe';
        obj.age = 40;
        obj.height = 200;

        console.log(obj);
</script>

实行结果：
{name: "why", age: 18, height: 188}
{name: "kobe", age: 40, height: 200} 
```
### 5.3 ES6对象字面量的增强写法
ES6中，对对象字面量进行了很多增强。<br/>
```
<body>
    <script>

        //1.属性的增强写法
        const name = 'why';
        const age = 18;
        const height = 1.88;

        //ES5的写法
        /*
        const obj1 = {
            name: name,
            age: age,
            height: height
        }
        */

        //ES6的写法
        const obj1 = {
            name,
            age,
            height,
        }
        console.log(obj1);

        //2.函数的增强写法
        //ES5的写法
        /*
        const obj2 = {
            run: function () {

            },
            eat: function () {

            }
        }
        */

        //ES6的写法
        const obj2 = {
            run() {

            },
            eat() {

            }
        }

    </script>
</body>
```
## 6. `v-on` 事件监听
在前端开发中，我们需要经常处理和用户之间的交互。
- 在这个时候，我们就必须监听用户发生的事件，比如点击，拖拽，键盘事件等等
- 在`Vue`中如何监听事件呢？使用`v-on`指令
### 6.1 `v-on`的基本使用和语法糖
- 作用：绑定事件监听器
- 缩写：`@`
- 预期：`Function`|`Inline Statement`|`Object`
- 参数：`event` 
```
<body>
    <div id="app">
        <h2>{{counter}}</h2>
        <!-- <button v-on:click="add">+</button> -->
        <!-- <button v-on:click="sub">-</button> -->
        <button @click="add">+</button>
        <button @click="sub">-</button>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                counter: 0
            },
            computed: {

            },
            methods: {
                add(){
                    this.counter++
                },
                sub(){
                    this.counter--
                }
            }
        })
    </script>
</body>
```
### 6.2 `v-on`的参数传递问题
当通过`methods`中定义方法，以供`@click`调用时，需要注意参数问题：
- 情况一：如果该方法不需要额外参数，那么方法后的`()`可以不添加。
  - 注意：如果方法本身中有一个参数，那么会默认将原生事件`event`参数传递进去
- 情况二：如果需要同时传入某个参数，同时需要`event`时，可以通过`$event`传入事件
```
<body>
    <div id="app">
        <!-- 第一种情况 -->
        <!-- 事件调用的方法没有参数 -->
        <button @click="clickBtn1()">按钮1</button>
        <button @click="clickBtn1">按钮1</button>

        <!-- 第二种情况 -->
        <!-- 在事件定义时，写方法时省略了小括号，但是方法本身是需要一个参数的 -->
        <!-- 这个时候Vue会默认将浏览器生成的event事件对象作为参数传入到方法中 -->
        <button @click="clickBtn2">按钮2</button>

        <!-- 第三种情况 -->
        <!-- 方法定义时，我们需要event对象，同时又需要其他参数 -->
        <!-- 在调用方法时，如何手动的获取到浏览器形成的event对象：$event -->
        <button @click="clickBtn3(123,$event)">按钮3</button>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el:'#app',
            data:{
                message:'模版'
            },
            methods:{
                clickBtn1(){
                    console.log('clickBtn1')
                },
                clickBtn2(event){
                    console.log('------',event)
                },
                clickBtn3(abc,event){
                    console.log('++++++',abc,event)
                }
            }
        })
    </script>
</body>
```
### 6.3 `v-on`的修饰符使用
在某些情况下，我们拿到`event`的目的可能是进行一些事件处理。<br/>
`Vue`提供了修饰符来帮助我们方便的处理一些事件。<br/>
- `.stop`：调用`event.stopPropagation()`
- `.prevent`：调用`event.preventDefault()`
- `.{keyCode|keyAlias}`：只当事件是从特定触发时才触发回调。
- `.native`：监听组件根元素的原生事件
- `.once`：只触发一次回调
```
<body>
    <div id="app">

        <!-- 1. .stop修饰符的使用 -->
        <div @click="divClick">
            -----
            <!-- 为了避免事件冒泡，需加.stop来阻止冒泡事件 -->
            <button @click.stop="btnClick">按钮</button>
        </div>

        <br /><br />

        <!-- 2. .prevent修饰符的使用 -->
        <form action="google">
            <!-- 阻止点击按钮时自动提交数据时，可以使用.prevent -->
            <input type="submit" value="提交" @click.prevent="submitClick">
        </form>

        <br /><br />

        <!-- 3. 监听某个键盘键的点击 -->
        <!-- <input type="text" @keyup="keyUp"> -->
        <!-- 敲回车键松开显示keyUp -->
        <input type="text" @keyup.enter="keyUp">

        <br /><br />

        <!-- 4. .once修饰符的使用 -->
        <!-- 按钮2被点击一次会有反应，再点击将没有反应 -->
        <button @click.once="btn2Click">按钮2</button>

    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {

            },
            methods: {
                btnClick() {
                    console.log("btnClick");
                },
                divClick() {
                    console.log("divClick");
                },
                submitClick() {
                    console.log("submitClick");
                },
                keyUp() {
                    console.log("keyUp");
                },
                btn2Click() {
                    console.log("btn2Click");
                }
            }
        })
    </script>
</body>
```
## 7. `v-if`和`v-else-if`和`v-else`的使用
### 7.1 `v-if`，`v-else-if`，`v-else`
- 这三个指令与Javacript的条件语句`if`，`else`，`else if`类似
- `Vue`的条件指令可以根据表达式的值在`DOM`中渲染或销毁元素或组件
- `v-if`后面的条件为`false`时，对应的元素以及其子元素不会渲染
- 也就是根本不会有对应的标签出现在`DOM`中
```
<body>
    <div id="app">
        <!-- 第一种实现方式 -->
        <div v-if="score >=  90">秀</div>
        <div v-else-if="score >= 80">优</div>
        <div v-else-if="score >= 70">良</div>
        <div v-else-if="score >= 60">及格</div>
        <div v-else>不及格</div>

        <!-- 第二种实现方式 -->
        <div>{{result}}</div>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                score: 90
            },
            computed: {
                result() {
                    let showMessage = '';
                    if (this.score >= 90) {
                        showMessage = '秀';
                    } else if (this.score >= 80) {
                        showMessage = '优';
                    } else if (this.score >= 70) {
                        showMessage = '良';
                    } else if (this.score >= 60) {
                        showMessage = '及格';
                    } else {
                        showMessage = '不及格';
                    }
                    return showMessage;
                }
            }
        })
    </script>
</body>
```
### 7.2 用户登录切换的案例
```
<body>
    <div id="app">
        <span v-if="isUser">
            <label for="username">用户账号</label>
            <input type="text" id="username" placeholder="请输入用户账号" key="username">
        </span>
        <span v-else>
            <label for="email">用户邮箱</label>
            <input type="text" id="email" placeholder="请输入邮箱地址" key="email">
        </span>
        <button @click="isUser=!isUser">类型切换</button>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                isUser: true
            }
        })
    </script>
</body>
```
### 7.3 `v-if`和`v-show`的区别
`v-show`的用法和`v-if`非常相似，也用于决定一个元素是否渲染。<br/>
`v-show`和`v-if`对比：<br/>
- `v-show`和`v-if`都可以决定一个元素是否渲染，那么开发中我们如何选择呢？
  - `v-if`当条件为`false`时，压根不会有对应的元素在DOM中
  - `v-show`当条件为`false`时，仅仅时将元素的`display`属性设置为`none`而已
- 开发中如何选择呢？
  - 当需要在显示与隐藏之间切换很频繁时，使用`v-show`
  - 当只有一次切换时，通过使用`v-if`
```
<body>
    <div id="app">
        <!-- v-if：当条件为false时，包含v-if指令的元素，根本就不会存在在dom中 -->
        <h2 v-if="isShow" id="aaa">{{message}}</h2>
        
        <!-- v-show：当条件为false时，v-show只是给我们的元素添加一个行内样式：display:none -->
        <h2 v-show="isShow" id="bbb">{{message}}</h2>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: 'Hello!',
                isShow: true
            },
        })
    </script>
</body>
```
## 8. `v-for`
### 8.1 `v-for`遍历数组和对象
当我们有一组数据需要进行渲染时，我们就可以使用`v-for`来完成。<br/>
- `v-for`的语法类似于JavaScript中的`for`循环 
- 格式：`item in items`
案例：<br/>
- 如果在遍历的过程中不需要使用索引值
  - 语法格式：`v-for="movie in movies"`
  - 依次从`movies`中取出`movie`，并且在元素的内容中，我们可以使用`Mustache`语法，来使用`movie`
- 如果在遍历的过程中，我们需要拿到元素在数组中的索引值
  - 语法格式：`v-for="(item,index) in items"`
  - 其中的`index`就代表了取出的`item`在原数组中的索引值
- 遍历数组
```
<body>
    <div id="app">
        <!-- 1. 在遍历的过程中，没有使用索引值(下标值) -->
        <ul>
            <li v-for="name in names">{{name}}</li>
        </ul>

        <!-- 2. 在遍历的过程中，获取索引值 -->
        <ul>
            <li v-for="(name,index) in names">{{index+1}}. {{name}}</li>
        </ul>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                names: ['why', 'kobe', 'james', 'curry']
            }
        })
    </script>
</body>

实行结果：
why
kobe
james
curry

1. why
2. kobe
3. james
4. curry
```
- 遍历对象
```
<body>
    <div id="app">
        <!-- 1. 在遍历对象的过程中，如果只是获取一个值，那么获取的是value -->
        <ul>
            <li v-for="infoDeital in info">{{infoDeital}}</li>
        </ul>

        <!-- 2. 获取key和value 格式：(value, key)-->
        <ul>
            <li v-for="(infoDeital,key) in info">{{key}}: {{infoDeital}}</li>
        </ul>

        <!-- 3. 获取key，value和index 格式：(value, key, index)-->
        <ul>
            <li v-for="(infoDeital,key,index) in info">{{index}}. {{key}}: {{infoDeital}}</li>
        </ul>

    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                info: {
                    name: 'James',
                    age: 18,
                    height: 178
                }
            }
        })
    </script>
</body>

实行结果：
James
18
178

name: James
age: 18
height: 178

0. name: James
1. age: 18
2. height: 178
```
### 8.2 `v-for`绑定和非绑定`key`的区别
官方推荐我们在使用`v-for`时，给对应的元素或组件添加上一个`:key`属性 <br/>
`key`的作用主要是为了高效的更新虚拟`DOM` <br/>
```
<body>
    <div id="app">
        <ul>
            <li v-for="item in letters" :key="item">{{item}}</li>
        </ul>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                letters: ['A', 'B', 'C', 'D', 'E']
            }
        })
    </script>
</body>
```
### 8.3 数组中哪些方法是响应式的 
因为Vue是响应式的，所以当数据发生变化时，Vue会自动检测数据变化，视图会发生对应的更新。<br/>
Vue中包含了一组观察数组编译的方法，使用它们改变数组也会触发视图的更新。<br/>
- `push()`：向数组后面添加元素
- `pop()`：删除数组中的最后一个元素
- `shift()`：删除数组中的第一个元素
- `unshift()`：在数组最前面添加元素
- `splice()`：
    - 删除元素：两个参数
      - 第一个参数：开始位置
      - 第二个参数：删除元素的个数，如果没有传参，则删除后面所有的元素
    - 插入元素：
      - 第一个参数：开始位置
      - 第二个参数：0
      - 第三个参数：插入的元素
    - 替换元素：N个参数
      - 第一个参数：开始位置
      - 第二个参数：替换元素的个数
      - 第三～N个参数：替换的内容
- `sort()`：从小到大排列
- `reverse()`：反转
- `Vue.set(要修改的对象,索引值 ,修改后的值)`
```
<body>
    <div id="app">
        <ul>
            <li v-for="item in letters">{{item}}</li>
            <button @click="btnClick">按钮</button>
        </ul>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                letters: ['A', 'B', 'C', 'D', 'E']
            },
            methods: {
                btnClick() {
                    // 1. push方法
                    // this.letters.push('aaa','bbb','ccc') //ABCDEaaabbbccc

                    //2. pop方法
                    // this.letters.pop() //ABCD

                    //3. shift
                    // this.letters.shift() //BCDE

                    //4. unshift
                    // this.letters.unshift('H','J','K') //HJKABCDE

                    //5. splice()
                    //5.1 删除元素
                    // this.letters.splice(1,2); //ADE
                    
                    //5.2 插入元素
                    // this.letters.splice(1,0,'H');//AHBCDE

                    //5.3 替换元素
                    // this.letters.splice(1,2,'H','I'); //AHIDE

                    //6. sort()
                    // this.letters.sort(); //ABCDE

                    //7. reverse()
                    this.letters.reverse(); //EDCBA

                    //8. Vue.set()
                    Vue.set(this.letters,0,'bbb') //bbbBCDE
                }
            }
        })
    </script>
</body>
```
- 注意：通过索引值修改数组中的元素不是响应式的
```
this.letters[0] = 'bbb'
```
## 9. 购物车案例
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>购物车案例</title>
    <style>
        /* * {
            margin: 0px;
            padding: 0px;
        } */

        table {
            border: 1px solid #e9e9e9;
            /* 设置边框合并 */
            border-collapse: collapse;
            margin-top: 20px;
            margin-left: 20px;
        }

        th,
        td {
            padding: 8px 16px;
            border: 1px solid #e9e9e9;
        }

        th {
            background-color: #f7f7f7;
            color: #5c6b77;
            font-weight: 600;
        }

        h4 {
            margin-left: 20px;
        }
    </style>
</head>
<body>
    <div id="app">
        <div v-if="books.length >= 1">
            <table>
                <thead>
                    <tr>
                        <th></th>
                        <th>书籍名称</th>
                        <th>出版日期</th>
                        <th>价格</th>
                        <th>购买数量</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody>
                    <tr v-for="(book,index) in books">
                        <!-- <td v-for="value in book">{{value}}</td> -->
                        <td>{{book.id}}</td>
                        <td>{{book.name}}</td>
                        <td>{{book.date}}</td>
                        <!-- 第一种方法：取得书籍的价格 -->
                        <!-- <td>{{getPrice(book.price)}}</td> -->

                        <!-- 第二种方法：取得书籍的价格 -->
                        <td>{{book.price | showPrice}}</td>
                        <td>
                            <button @click="add(index)">+</button>
                            {{book.count}}
                            <!-- disabled: 不能操作 -->
                            <button @click="sub(index)" :disabled="book.count <= 1">-</button>
                        </td>
                        <td><button @click="remove(index)">移除</button></td>
                    </tr>
                </tbody>
            </table>
            <h4>合计：{{totalPrice | showPrice}}</h4>
        </div>
        <h2 v-else>购物车为空</h2>
    </div>
    <script src="../Vuejs/js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                counter: 0,
                index: 0,
                books: [
                    {
                        id: 1,
                        name: '《算法导论》',
                        date: '2006-9',
                        price: 85.00,
                        count: 1
                    },
                    {
                        id: 2,
                        name: '《UNIX编程艺术》',
                        date: '2006-2',
                        price: 59.00,
                        count: 1
                    },
                    {
                        id: 3,
                        name: '《编程珠玑》',
                        date: '2008-2',
                        price: 39.00,
                        count: 1
                    },
                    {
                        id: 4,
                        name: '《代码大全》',
                        date: '2006-3',
                        price: 128.00,
                        count: 1
                    },
                ]
            },

            methods: {
                // getPrice(price) {
                //     return '¥' + price.toFixed(2)
                // },
                add(index) {
                    // console.log("add",index);
                    this.books[index].count++
                },
                sub(index) {
                    // console.log("sub",index);
                    this.books[index].count--;
                    // if (this.books[index].count < 1) {
                    //     this.books[index].count = 1;
                    // }
                },
                remove(index) {
                    // confirm 用于弹出一个带有确认和取消按钮的提示框
                    let flag = confirm("确定要删除" + this.books[index].name + "吗？");
                    // 如果用户点击【确认】，则会返回true；如果点击【取消】，则会返回false
                    if (flag) {
                        this.books.splice(index, 1);
                    }
                }
            },
            computed: {
                totalPrice() {
                    let totalPrice = 0;
                    // 第一种for循环写法
                    /*
                    for (let i = 0; i < this.books.length; i++) {
                        totalPrice += this.books[i].price * this.books[i].count;
                    }
                    return totalPrice;
                    */

                    //第二种for循环写法   
                    /* 
                    for (let i in this.books) {
                        totalPrice += this.books[i].price * this.books[i].count;
                    }
                    return totalPrice;
                    */

                    //第三种for循环写法
                    /*
                    for(let book of this.books){
                        totalPrice += book.price * book.count;
                    }
                    return totalPrice;
                    */

                    //第四种写法
                    return this.books.reduce(function (prePrice, book) {
                        return prePrice + book.price * book.count
                    }, 0)
                }
            },
            //过滤器被用于文本格式化: 由于价格和合计都需要加¥和小数点两位，所以可以用过滤器
            filters: {
                showPrice(price) {
                    return '¥' + price.toFixed(2)
                }
            }
        })
    </script>
</body>
</html>
```
## 10. JavaScript高阶函数的使用
- 编程范式：命令式编程/声明式编程
- 编程范式：面向对象编程(第一公民：对象)/函数式编程(第一公民：函数) <br/>
高阶函数 <br/>
- `filter`函数的使用
  - `filter`中的回调函数有一个要求：必须返回一个`boolean`值
  - 当返回`true`时，函数内部会自动将这次回调的`n`加入到新的数组中
  - 当返回`false`时，函数内部会过滤掉这次的`n`
```
需求一：取出数组中所有小于100的数字

//方法一：
const nums = [10, 20, 111, 222, 444, 40, 50];

let newNums = [],
for (let n of nums) {
    if (n < 100) {
        newNums.push(n);
    }
}

//方法二：
const nums = [10, 20, 111, 222, 444, 40, 50];

let newNums = nums.filter(function (n) {
    return n < 100
})

实行结果：
10 20 40 50
```
- `map`函数的使用 <br/>
作用：将数组中的所有数组进行变化
```
需求二：承接上述例子，将所有小于100的数字进行转化：全部*2

//方法一：
let newValues = [],
for (let n of newNums) {
    newValues.push(n * 2);
}

//方法二：
let newValues = newNums.map(function(n){
    return n * 2
})

实行结果：
20 40 80 100
```
- `reduce`函数的使用 <br/>
作用：对数组中所有的内容进行汇总
```
需求三： 将所有newValues数字相加，得到最终的结果

//方法一：
let total = 0;
for (let n of newValues) {
    total += n;
}

//方法二：
let total = newValues.reduce(function (preValue, n) {
    return preValue + n
}, 0) //preValue的初始值为0

//第一次：preValue=0, n=20,return:20
//第二次：preValue=20,n=40,return:60
//第三次：preValue=60,n=80,return:140
//第四次：preValue=140,n=100,return:240

实行结果：
240
```
```
使用高阶函数，将上述三个需求同时实现：（函数式编程）

const nums = [10, 20, 111, 222, 444, 40, 50]

let total = nums.filter(function (n) {
    return n < 100
}).map(function (n) {
    return n * 2
}).reduce(function (preValue, n) {
    return preValue + n
}, 0)

实行结果：
240
```
```
将上述的高阶函数使用箭头函数再次简化：

let total = nums.filter(n => n < 100).map(n => n * 2).reduce((pre, n) => pre + n);
```
## 11. `v-model`
### 11.1 `v-model`的使用和原理
- `v-model`：表单绑定
  - 表单控件在实际开发中是非常常见的，特别是对于用户信息的提交，需要大量的表单。
  - `Vue`中使用`v-model`指令来实现表单元素和数据的双向绑定。
```
//输入框里输入的内容会显示到message上
<body>
    <div id="app">
        
        <!-- 第一种实现方法 -->
        <!-- <input type="text" :value="message" @input="valueChange"> -->
        
        <!-- 第二种实现方法 -->
        <!-- <input type="text" :value="message" @input="message=$event.target.value"> -->
        
        <!-- 第三种实现方法 -->
        <input type="text" v-model="message">
        <h2>{{message}}</h2>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: '模版'
            },
            /*
            methods: {
                valueChange(event) {
                    this.message = event.target.value;
                }
            }
            */
        })
    </script>
</body>
```
- `v-model`原理
  - `v-model`是一个语法糖，它的背后本质上可以包含两个操作
    - `v-bind`绑定一个`value`属性
    - `v-on`指令给当前元素绑定`input`事件
### 11.2 `v-model`结合`radio`类型使用
单选按钮 <br/>
```
//选择性别，并将选择的值提交

<body>
    <div id="app">
        <label for="male">
            <input type="radio" id="male" value="男" v-model="sex">男
        </label>
        <label for="female">
            <input type="radio" id="female" value="女" v-model="sex">女
        </label>
        <h3>您选择的性别是：{{sex}}</h3>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: 'Hello',
                // 默认值为男
                sex: '男'
            }
        })
    </script>
</body>

实行结果：
- 点击男 --> 您选择的性别是：男
- 点击女 --> 您选择的性别是：女
```
### 11.3 `v-model`结合`checkbox`类型使用
复选框分为两种情况：单个勾选框和多个勾选框。<br/>
```
<body>
    <div id="app">
        <!-- 1. checkbox单选框 -->
        <label for="agreement">
            <input type="checkbox" id="agreement" v-model="agreement">同意协议
        </label>

        <h3>您选择的是：{{agreement}}</h3>
        <button :disabled="!agreement">下一步</button>

        <br /><br />

        <!-- 2. checkbox多选框 -->
        <input type="checkbox" value="篮球" v-model="hobbies">篮球
        <input type="checkbox" value="足球" v-model="hobbies">足球
        <input type="checkbox" value="排球" v-model="hobbies">排球
        <input type="checkbox" value="棒球" v-model="hobbies">棒球
        <input type="checkbox" value="网球" v-model="hobbies">网球

        <h3>您的爱好是：{{hobbies}}</h3>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: 'Hello',
                //默认为没选中
                agreement: false, //单选框：对应的是boolean类型
                hobbies: [] //多选框：对应的是数组类型
            }
        })
    </script>
</body>
```
### 11.4 `v-model`结合`select`类型使用
和`checkbox`一样，`select`也分单选和多选两种情况。<br/>
```
<body>
    <div id="app">
        <!-- 1. 选择一个 -->
        <select name="abc" v-model="fruit">
            <option value="苹果">苹果</option>
            <option value="香蕉">香蕉</option>
            <option value="橘子">橘子</option>
            <option value="橙子">橙子</option>
            <option value="柿子">柿子</option>
        </select>
        <h3>您选择的水果是：{{fruit}}</h3>

        <!-- 2. 选择多个 -->
        <select name="abc" v-model="fruits" multiple>
            <option value="苹果">苹果</option>
            <option value="香蕉">香蕉</option>
            <option value="橘子">橘子</option>
            <option value="橙子">橙子</option>
            <option value="柿子">柿子</option>
        </select>
        <h3>您选择的水果是：{{fruits}}</h3>

    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: 'Hello',
                fruit: '香蕉',
                fruits: []
            }
        })
    </script>
</body>

实行结果：
- 点击哪个水果就会提交哪个水果
- 点击多个水果就会提交多个水果
```
### 11.5 `input`中的值绑定
- 前面所述的`value`中的值，都是在定义`input`的时候直接给定的
- 但在实际开发中，这些`input`的值可能是从网络获取或定义在`data`中的
- 所以我们可以通过`v-bind:value`动态的给`value`绑定值
```
<body>
    <div id="app">
        
        <label v-for="hobby in originHobbies" :for="hobby">
            <input type="checkbox" :value="hobby" :id="hobby" v-model="hobbies">{{hobby}}
        </label>

        <h3>您的爱好是：{{hobbies}}</h3>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                hobbies: [], //多选框：对应的是数组类型
                originHobbies: ['篮球', '足球', '乒乓球', '羽毛球', '台球', '高尔夫球']
            }
        })
    </script>
</body>

实行结果：
点击哪个爱好就会将其添加到定义好的hobbies数组中
```
### 11.6 `v-model`修饰符的使用
#### 11.6.1 `lazy`修饰符(懒加载)
- 默认情况下，`v-model`默认是在`input`事件中同步输入框的数据的 
- 也就是说，一旦有数据发生改变对应的`data`中的数据就会自动发生改变
- `lazy`修饰符可以让数据在失去焦点或者按回车时才会更新

#### 11.6.2 `number`修饰符
- 默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串型进行处理
- 但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理
- `number`修饰符可以让在输入框中输入的内容自动转成数字类型

#### 11.6.3 `trim`修饰符
- 如果输入的内容首尾有很多空格，通常我们希望将其去除
- `trim`修饰符可以过滤内容左右两边的空格
```
<body>
    <div id="app">
        <!-- 1. 修饰符 lazy -->
        <input type="text" v-model.lazy="message">
        <h3>您输入的是：{{message}}</h3>

        <!-- 2. 修饰符 number -->
        <input type="number" v-model.number="age">
        <h3>您输入的年龄是：{{age}}:{{typeof age}}</h3>

        <!-- 3. 修饰符 trim-->
        <input type="text" v-model.trim="name">
        <h3>您输入的名字是：{{name}}</h3>

    </div>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: 'Hello',
                age: 0,
                name: ''
            }
        })
    </script>
</body>

实行结果：
1. 输入的内容不会马上提交，只有当焦点离开或是按回车键之后，输入的内容才会被提交
2. 输入的年龄会转换成number类型
3. 输入的名字如果前后有空格，会自动将其删除。在控制台中检查app.name
```
## 12. 组件化
### 12.1 组件化的实现和使用步骤 
#### 12.1.1 组件化思想
如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，<br/>
而且不利于后续的管理以及扩展。但如果，我们将一个页面拆分成一个个小的功能块，<br/>
每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了。<br/>
- 将一个完整的页面分成很多个组件
- 每个组件都用于实现页面的一个功能块
- 而每一个组件又可以进行细分
#### 12.1.2 Vue组件化思想
组件化是Vue.js中的重要思想。<br/>
- 它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用
- 任何的应用都会被抽象成一棵组件树
#### 12.1.3 注册组件的基本步骤
组件的使用分成三个步骤： <br/>
- 创建组件构造器：调用`Vue.extend()`方法创建组件构造器
- 注册组件：调用`Vue.component()`方法注册组件
- 使用组件：在`Vue`实例的作用范围内使用组件
### 12.2 组件化的基本使用过程
```
<body>
    <div id="app">
        <!-- 3. 使用组件 -->
        <cpn></cpn>
        <cpn></cpn>
        <cpn></cpn>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        // 1. 创建组件构造器对象
        const cpnCtr = Vue.extend({
            template: `
                <div>
                    <h3>夜雨</h3>
                    <p>我有所念人，隔在远远乡。</p>
                    <p>我有所感事，结在深深肠。</p>    
                </div>
            `
        })
        // 2. 注册组件
        Vue.component('cpn', cpnCtr)

        const app = new Vue({
            el: '#app'
        })
    </script>
</body>

实行结果：

夜雨
我有所念人，隔在远远乡。
我有所感事，结在深深肠。

夜雨
我有所念人，隔在远远乡。
我有所感事，结在深深肠。

夜雨
我有所念人，隔在远远乡。
我有所感事，结在深深肠。
```
### 12.3 全局组件和局部组件
- 全局组件
```
<body>
    <div id="app">
        <!-- 3. 使用组件 -->
        <cpn></cpn>
    </div>
    <div id="app2">
        <cpn></cpn>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        // 1. 创建组件构造器
        const cpnCtr = Vue.extend({
            template: `
                <div>
                    <h3>长恨歌</h3>
                    <p>在天愿作比翼鸟，在地愿为连理枝。</p>
                    <p>天长地久有时尽，此恨绵绵无绝期。</p>
                </div>
            `
        })

        // 2. 注册组件(全局组件：意味着可以在多个Vue的实例下面使用)
        Vue.component('cpn', cpnCtr)

        const app = new Vue({
            el: '#app',
        })

        const app2 = new Vue({
            el: '#app2',
        })
    </script>
</body>

实行结果：

长恨歌
在天愿作比翼鸟，在地愿为连理枝。
天长地久有时尽，此恨绵绵无绝期。

长恨歌
在天愿作比翼鸟，在地愿为连理枝。
天长地久有时尽，此恨绵绵无绝期。
```
- 局部组件(开发中一般用局部组件)
```
<body>
    <div id="app">
        <!-- 3. 使用组件 -->
        <cpn></cpn>
    </div>
    <div id="app2">
        <cpn></cpn>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        // 1. 创建组件构造器
        const cpnCtr = Vue.extend({
            template: `
                <div>
                    <h3>长恨歌</h3>
                    <p>在天愿作比翼鸟，在地愿为连理枝。</p>
                    <p>天长地久有时尽，此恨绵绵无绝期。</p>
                </div>
            `
        })

        // 2. 注册组件(全局组件：意味着可以在多个Vue的实例下面使用)
        // Vue.component('cpn', cpnCtr)

        const app = new Vue({
            el: '#app',
            //2. 注册组件(局部组件)
            components: {
                //标签名: 组件构造器
                cpn: cpnCtr
            }
        })

        const app2 = new Vue({
            el: '#app2',
        })
    </script>
</body>

实行结果：

长恨歌
在天愿作比翼鸟，在地愿为连理枝。
天长地久有时尽，此恨绵绵无绝期。
```
### 12.4 父组件和子组件的区分
- 组件和组件之间存在层级关系
- 而其中一种非常重要的关系就是父子组件的关系
```
<body>
    <div id="app">
        <cpn2></cpn2>
    </div>

    <script src="../js/vue.js"></script>
    <script>
        // 1. 创建第一个组件构造器(子组件)
        const cpnCtr1 = Vue.extend({
            template: `
                <div>
                    <h3>登高</h3>
                    <p>风急天高猿啸哀，渚清沙白鸟飞回。</p>
                    <p>无边落木萧萧下，不尽长江滚滚来。</p>
                    <p>万里悲秋常作客，百年多病独登台。</p>
                    <p>艰难苦恨繁霜鬓，潦倒新停浊酒杯。</p>
                </div>
            `
        })

        // 2. 创建第二个组件构造器(父组件)
        const cpnCtr2 = Vue.extend({
            template: `
                <div>
                    <h3>春夜喜雨</h3>
                    <p>好雨知时节，当春乃发生。</p>
                    <p>随风潜入夜，润物细无声。</p>
                    <p>野径云俱黑，江船火独明。</p>
                    <p>晓看红湿处，花重锦官城。</p>
                    <cpn1></cpn1>
                </div> 
            `,
            //2. 注册组件cpnCtr1
            components: {
                //标签名:组件构造器
                cpn1: cpnCtr1
            }
        })

        const app = new Vue({
            el: '#app',
            // 2. 注册组件cpnCtr2
            components: {
                //标签名:组件构造器
                cpn2: cpnCtr2
            }
        })
    </script>
</body>

实行结果：

春夜喜雨

好雨知时节，当春乃发生。
随风潜入夜，润物细无声。
野径云俱黑，江船火独明。
晓看红湿处，花重锦官城。

登高

风急天高猿啸哀，渚清沙白鸟飞回。
无边落木萧萧下，不尽长江滚滚来。
万里悲秋常作客，百年多病独登台。
艰难苦恨繁霜鬓，潦倒新停浊酒杯。
```
### 12.5 注册组件的语法糖写法
`Vue`为了简化组册组件的方式，提供了注册的语法糖。<br/>
主要是省去了调用`Vue.extend()`的步骤，而是可以直接使用一个对象来代替。<br/>
- 全局组件的语法糖写法
```
<body>
    <div id="app">
        <cpn></cpn>
    </div>

    <script src="../js/vue.js"></script>
    <script>
        // 1.1 创建组件构造器
        /*
        const cpnCtr = Vue.extend({
            template: `
                <div>
                    <h3>登高</h3>
                    <p>风急天高猿啸哀，渚清沙白鸟飞回。</p>
                    <p>无边落木萧萧下，不尽长江滚滚来。</p>
                    <p>万里悲秋常作客，百年多病独登台。</p>
                    <p>艰难苦恨繁霜鬓，潦倒新停浊酒杯。</p>
                </div>
            `
        })
        */
        // 1.2 注册组件
        //Vue.component('cpn', cpnCtr)

        //1. 全局组件注册的语法糖
        Vue.component('cpn', {
            template: `
                <div>
                    <h3>登高</h3>
                    <p>风急天高猿啸哀，渚清沙白鸟飞回。</p>
                    <p>无边落木萧萧下，不尽长江滚滚来。</p>
                    <p>万里悲秋常作客，百年多病独登台。</p>
                    <p>艰难苦恨繁霜鬓，潦倒新停浊酒杯。</p>
                </div>
            `
        })

        const app = new Vue({
            el: '#app'
        })
    </script>
</body>

实行结果：

登高

风急天高猿啸哀，渚清沙白鸟飞回。
无边落木萧萧下，不尽长江滚滚来。
万里悲秋常作客，百年多病独登台。
艰难苦恨繁霜鬓，潦倒新停浊酒杯。
```
- 局部组件的语法糖写法
```
<body>
    <div id="app">
        <cpn></cpn>
    </div>

    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            // 2. 注册局部组件
            components: {
                // 1. 创建局部组件构造器
                cpn: {
                    template: `
                        <div>
                            <h3>登高</h3>
                            <p>风急天高猿啸哀，渚清沙白鸟飞回。</p>
                            <p>无边落木萧萧下，不尽长江滚滚来。</p>
                            <p>万里悲秋常作客，百年多病独登台。</p>
                            <p>艰难苦恨繁霜鬓，潦倒新停浊酒杯。</p>
                        </div>
                    `
                }
            }
        })
    </script>
</body>

实行结果：

登高

风急天高猿啸哀，渚清沙白鸟飞回。
无边落木萧萧下，不尽长江滚滚来。
万里悲秋常作客，百年多病独登台。
艰难苦恨繁霜鬓，潦倒新停浊酒杯。
```
### 12.6 组件模版抽离的写法
组件模版分离方法： <br/>
- 使用`script`标签
- 使用`template`标签
```
<body>
    <div id="app">
        <cpn></cpn>
    </div>

    <!-- 组件模版抽离的第一种写法：script标签，注意：类型必须是text/x-template -->
    <!-- <script type="text/x-template" id="cpn">
        <div>
            <h3>登高</h3>
            <p>风急天高猿啸哀，渚清沙白鸟飞回。</p>
            <p>无边落木萧萧下，不尽长江滚滚来。</p>
            <p>万里悲秋常作客，百年多病独登台。</p>
            <p>艰难苦恨繁霜鬓，潦倒新停浊酒杯。</p>
        </div>
    </script> -->

    <!-- 组件模版抽离的第二种写法：template标签 -->
    <template id="cpn">
        <div>
            <h3>登高</h3>
            <p>风急天高猿啸哀，渚清沙白鸟飞回。</p>
            <p>无边落木萧萧下，不尽长江滚滚来。</p>
            <p>万里悲秋常作客，百年多病独登台。</p>
            <p>艰难苦恨繁霜鬓，潦倒新停浊酒杯。</p>
        </div>
    </template>

    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            // 2. 注册局部组件
            components: {
                // 1. 创建局部组件构造器
                cpn: {
                    template: '#cpn'
                }
            }
        })
    </script>
</body>

实行结果：

登高

风急天高猿啸哀，渚清沙白鸟飞回。
无边落木萧萧下，不尽长江滚滚来。
万里悲秋常作客，百年多病独登台。
艰难苦恨繁霜鬓，潦倒新停浊酒杯。
```
### 12.7 为什么组件`data`必须是函数
- 组件是一个单独功能模块的封装
  - 这个模块有属于自己的HTML模版，也应该有属于自己的数据`data`
- 组件中的数据是保存在哪里呢？
  - 组件对象也有一个`data`属性，也可以有`methods`等属性
  - 只是这个`data`属性必须是一个函数
  - 而且这个函数返回一个对象，对象内部保存这数据
```
<body>
    <div id="app">
        <cpn></cpn>
    </div>

    <!-- 组件模版抽离的第二种写法：template标签 -->
    <template id="cpn">
        <div>
            <h3>{{title}}</h3>
            <p>风急天高猿啸哀，渚清沙白鸟飞回。</p>
            <p>无边落木萧萧下，不尽长江滚滚来。</p>
            <p>万里悲秋常作客，百年多病独登台。</p>
            <p>艰难苦恨繁霜鬓，潦倒新停浊酒杯。</p>
        </div>
    </template>

    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            // 2. 注册局部组件
            components: {
                // 1. 创建局部组件构造器
                cpn: {
                    template: '#cpn',
                    // 组件中的data必须是函数
                    data() {
                        //必须返回一个实例对象
                        return {
                            title: '登高'
                        }
                    }
                }
            }
        })
    </script>
</body>

实行结果：

登高

风急天高猿啸哀，渚清沙白鸟飞回。
无边落木萧萧下，不尽长江滚滚来。
万里悲秋常作客，百年多病独登台。
艰难苦恨繁霜鬓，潦倒新停浊酒杯。
```
```
<body>
    <div id="app">
        <!-- 创建组件实例 -->
        <cpn></cpn>
        <cpn></cpn>
        <cpn></cpn>
    </div>

    <!-- 组件模版抽离的第二种写法：template标签 -->
    <template id="cpnContent">
        <div>
            <h2>当前计数：{{counter}}</h2>
            <button @click="add">+</button>
            <button @click="sub">-</button>
        </div>
    </template>

    <script src="../js/vue.js"></script>
    <script>
        // 1. 注册组件
        Vue.component('cpn', {
            template: '#cpnContent',
            data() {
                return {
                    counter: 0
                }
            },
            methods: {
                add() {
                    this.counter++
                },
                sub() {
                    this.counter--
                }
            }
        })

        const app = new Vue({
            el: '#app',
        })
    </script>
</body>

实行结果：

只有data是函数时，三个计时器才能独自进行加或减
而不是点击一个计时器按钮，三个计时器同时进行加或减
```
### 12.8 父子组件通信
组件是不能引用父组件或者Vue实例的数据的。<br/>
但是在开发中，往往一些数据需要从上层传递到下层 :<br/>
- 比如在一个页面中，我们从服务器请求到了很多的数据。
- 其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示
- 这个时候，并不会让子组件再次发送一个网络请求，而是直接让大组件(父组件)将数据传递个小组件(子组件)
#### 12.8.1 父传子`props`
如何进行父子组件间的通信呢？<br/>
- 父传子：通过属性`props`向子组件传递数据
- 子传父：通过事件`event`向父组件发送信息
- `props`基本用法：在组件中，使用`props`来声明需要从父级接收到的数据。
  - 方式一：字符串数组，数组中的字符串就是传递时的名称
  - 方式二：对象，对象可以设置传递时的类型，也可以设置默认值等
```
<body>
    <div id="app">
        <cpn :childmovies="movies"></cpn>
    </div>

    <template id="cpn">
        <div>
            <ul>
                <li v-for="movie in childmovies">{{movie}}</li>
            </ul>
        </div>
    </template>

    <script src="../js/vue.js"></script>
    <script>
        // 父传子：props
        const cpn = {
            template: '#cpn',

            //方式一：传数组
            // 这里的childmovies是一个变量
            // props: ['childmovies']

            //方式二：传对象：类型限制
            /*
            props: {
                // 传递的是数组类型
                childmovies: Array,
            }
            */

            //方式三：提供一些默认值，以及必传值
            props: {
                childmovies: {
                    //类型：数组
                    type: Array,
                    default: [],
                    required: true
                }
            }
        }
        const app = new Vue({
            el: '#app',
            data: {
                movies: ['怦然心动', '盗梦空间', '地心引力']
            },
            components: {
                cpn
            }
        })
    </script>
</body>

实行结果：
・怦然心动
・盗梦空间
・地心引力
```
#### 12.8.2 `props`驼峰标识
- 组件不支持驼峰标识，如果`props`里面定义的属性有大写的时候
- 在组件动态绑定时，需要将大写变小写，前面加`-`
```
<body>
    <div id="app">
        <!-- 组件不支持驼峰标识，应将大写变小写，前面加- -->
        <cpn :child-info="info"></cpn>
    </div>

    <template id="cpn">
        <div>
            <h2>{{childInfo}}</h2>
        </div>
    </template>

    <script src="../js/vue.js"></script>
    <script>
        const cpn = {
            template: '#cpn',
            props: {
                childInfo: {
                    type: Object,
                    default() {
                        return {}
                    }

                }
            }
        }

        const app = new Vue({
            el: '#app',
            data: {
                info: {
                    name: '孙悟空',
                    age: 18,
                    height: 150
                }
            },
            components: {
                cpn
            }
        })
    </script>
</body>
```
#### 12.8.3 子传父(自定义事件)
- 什么时候需要自定义事件呢？
  - 当子组件需要向父组件传递数据时，就要用到自定义事件
  - `v-on`不仅仅可以用于监听DOM事件，也可以用于组件间的自定义事件
- 自定义事件的流程
  - 在子组件中，通过`$emit()`来触发事件
  - 在父组件中，通过`v-on`来监听子组件事件
```
<body>
    <!-- 父组件模版 -->
    <div id="app">
        <cpn @item-click="cpnClick"></cpn>
    </div>

    <!-- 子组件模版 -->
    <template id="cpn">
        <div>
            <button v-for="item in categories" @click="btnClick(item)">{{item.name}}</button>
        </div>
    </template>

    <script src="../js/vue.js"></script>
    <script>
        // 1. 子组件
        const cpn = {
            template: "#cpn",
            data() {
                return {
                    categories: [
                        { id: '101', name: '热门推荐' },
                        { id: '102', name: '手机数码' },
                        { id: '103', name: '家用家电' },
                        { id: '104', name: '电脑办公' }
                    ]
                }
            },
            methods: {
                btnClick(item) {
                    //自定义事件，即发射事件：子组件传递给父组件，点击哪个按钮就要将此信息传递给父组件
                    this.$emit('item-click', item)
                }
            }
        }
        // 2. 父组件
        const app = new Vue({
            el: '#app',
            data: {
            },
            components: {
                cpn
            },
            methods: {
                cpnClick(item) {
                    console.log(item.name);
                }
            }
        })
    </script>
</body>

实行结果：

点击[热门推荐]按钮，控制台显示"热门推荐"
点击[手机数码]按钮，控制台显示"手机数码"
点击[家用家电]按钮，控制台显示"家用家电"
点击[电脑办公]按钮，控制台显示"电脑办公"
```
#### 12.8.4 父子组件通信-结合双向绑定案例 (盲点)
#### 12.8.5 父访问子-`children`或`refs`
有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问根组件 <br/>
父组件访问子组件：使用`$children`或`$refs` <br/>
- `$children`的访问
  - `this.$children`是一个数组类型，它包含所有子组件对象
  - 通过一个遍历，取出所有子组件的`message`状态
- `$refs`的访问
```
<body>
    <div id="app">
        <cpn></cpn>
        <cpn></cpn>
        <cpn ref="r"></cpn>
        <button @click="btnClick">按钮</button>
    </div>
    <template id="cpn">
        <div>
            我是子组件
        </div>
    </template>
    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: 'Hello'
            },
            methods: {
                btnClick() {
                    // 1. $children：数组
                    /*
                    console.log(this.$children);
                    this.$children[0].showMessage();
                    console.log(this.$children[0].name);
                    */

                    //遍历子组件
                    /*
                    for (let c of this.$children) {
                        c.showMessage();
                        console.log(c.name);
                    }
                    */ 

                    /*
                    上述的实行结果：
                        showMessage
                        我是子组件的name
                        showMessage
                        我是子组件的name
                        showMessage
                        我是子组件的name
                    */

                    //2. $refs：对象类型，默认是一个空的对象，ref='r'
                    this.$refs.r.showMessage();
                    console.log(this.$refs.r.name);
                }
            },
            components: {
                cpn: {
                    template: '#cpn',
                    data() {
                        return {
                            name: '我是子组件的name'
                        }
                    },
                    methods: {
                        showMessage() {
                            console.log('showMessage')
                        }
                    }
                }
            }
        })
    </script>
</body>

实行结果：
showMessage
我是子组件的name
```
#### 12.8.6 子访问父-`parent`或`root`
- 子组件访问父组件：使用`$parent`
- 访问根组件：使用`root`
```
<body>
    <div id="app">
        <cpn></cpn>
    </div>

    <template id="cpn">
        <div> 
            <h2>我是cpn组件</h2>
            <ccpn>
            </ccpn>
        </div>
    </template>

    <template id="ccpn">
        <div>
            <h2>我是子组件</h2>
            <button @click="btnClick">按钮</button>
        </div>
    </template>

    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {
                message: 'Hello'
            },
            components: {
                cpn: {
                    template: '#cpn',
                    data() {
                        return {
                            name: '我是cpn组件的name'
                        }
                    },
                    components: {
                        ccpn: {
                            template: '#ccpn',
                            methods: {
                                btnClick() {
                                    //1.访问父组件:$parent
                                    // console.log(this.$parent);
                                    // console.log(this.$parent.name);

                                    //2.访问根组件:$root
                                    console.log(this.$root);
                                    console.log(this.$root.message);
                                }
                            }
                        }
                    }
                }
            }
        })
    </script>
</body>
```
## 13. 插槽：`slot`
### 13.1 插槽的基本使用
- 组件的插槽是为了让我们封装的组件更加具有扩展性
- 让使用者可以决定组件内部的一些内容到底展示什么
- 例子：移动网站中的导航栏
  - 移动开发中，几乎每个页面都有导航栏
  - 导航栏我们必须会封装成一个插件，比如`nav-bar`组件
  - 一旦有了这个组件，我们就可以在多个网页中复用了
  - 每个页面的导航不是一样的，可以参考京东导航栏
- 如何去封装这类的组件呢？
  - 它们有很多区别，也有很多共性
  - 如果我们每一个单独去封装一个组件，显然不合适
    - 比如，每个页面都返回，这部分内容我们就要重复去封装
  - 但是，如果我们封装成一个，也不合理
    - 有些左侧是菜单，有些是返回，有些中间是搜索，有些是文字等等
- 如何封装合适呢？抽取共性，保留不同
  - 最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽
  - 一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容
  - 是搜索框，还是文字，还是菜单。由调用者自己来决定
```
<body>
    <!-- 
        1. 插槽的基本使用：在组件中加上<slot></slot>标签
        2. 插槽的默认值：<slot><button>按钮</button></slot>
        3. 如果有多个值，同时放入到组件进行替换时，一起作为替换元素
     -->
    <div id="app">
        <cpn><button>按钮</button></cpn>
        <cpn><span>span</span></cpn>
        <cpn><input type="text"></cpn>
        <cpn><button>提交</button></cpn>
        <cpn>
            <!-- 如果有多个值，同时放入到组件进行替换时，一起作为替换元素 -->
            <span>我是span元素</span>
            <p>我是p元素</p>
            <div>我是div元素</div>
        </cpn>
        <cpn></cpn>
        <cpn></cpn>
        <cpn></cpn>
        <cpn></cpn>
    </div>

    <template id="cpn">
        <div>
            <h2>我是组件</h2>
            <!-- 1. 插槽的基本使用：在组件中加上<slot></slot>标签 -->
            <!-- 2. 插槽的默认值：<slot><button>按钮</button></slot> -->
            <slot><button>slot中的按钮</button></slot>
        </div>
    </template>

    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {

            },
            components: {
                cpn: {
                    template: '#cpn',
                }
            }
        })
    </script>
</body>
```
### 13.2 具名插槽的使用 
```
<body>
    <div id="app">
        <cpn><span slot="center">替换中间</span></cpn>
        <cpn><button slot="left">替换左边</button></cpn>
        <cpn><input slot="right">替换右边</input></cpn>
    </div>

    <template id="cpn">
        <div>
            <slot name="left"><span>左边</span></slot>
            <slot name="center"><span>中间</span></slot>
            <slot name="right"><span>右边</span></slot>
        </div>
    </template>

    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {

            },
            components: {
                cpn: {
                    template: '#cpn',
                }
            }
        })
    </script>
</body>

实行结果：

左边 替换中间 右边
替换左边按钮 中间 右边
左边 中间 搜索框
```
### 13.3 编译作用域的概念
- 父组件模版的所有东西都会在父级作用域内编译
- 子组件模版的所有东西都会在子级作用域内编译
```
<body>
    <div id="app">
        <!-- 作用域是实例的作用域，而不是组件的，实例中的isShow为true -->
        <cpn v-show="isShow"></cpn>
    </div>

    <template id="cpn">
        <div>
            <h3>我是子组件的标题</h3>
            <!-- 作用域是组件的作用域，组件中isShow为false所以不显示 -->
            <p v-show="isShow">我是子组件的内容</p>
        </div>
    </template>

    <script src="../js/vue.js"></script>
    <script> 
        const app = new Vue({
            el: '#app',
            data: {
                isShow: true
            },
            components: {
                cpn: {
                    template: '#cpn',
                    data() {
                        return {
                            isShow: false
                        }
                    }
                }
            }
        })
    </script>
</body>

实行结果：

我是子组件的标题
```
### 13.4 作用域插槽的使用
父组件替换插槽的标签，但是内容由子组件来提供。<br/>
需求：<br/>
- 子组件中包括一组数组：比如：`pLanguages['JavaScript','Python','Swift','Go','C++']`
- 需要在多个界面进行展示：
  - 某些界面是以水平方向一一展示
  - 某些界面是以列表形式展示
  - 某些界面直接展示一个数组
- 内容在子组件，希望父组件告诉我们如何展示，怎么办呢？
  - 利用`slot`作用域插槽就可以了
```
<body>
    <div id="app">
        <cpn></cpn>
        <cpn>
            <!-- 目的是获取子组件中的pLanguages -->
            <template slot-scope="slot">
                <!-- 获取组件中的数据 -->
                <!-- <span v-for="item in slot.data">{{item}} - </span> -->
                <span>{{slot.data.join(' - ')}}</span>
            </template>
        </cpn>
        <cpn>
            <!-- 目的是获取子组件中的pLanguages -->
            <template slot-scope="slot">
                <!-- 获取组件中的数据 -->
                <!-- <span v-for="item in slot.data">{{item}} * </span> -->
                <span>{{slot.data.join(' * ')}}</span>
            </template>
        </cpn>
    </div>

    <template id="cpn">
        <div>
            <slot :data="pLanguages">
                <ul>
                    <li v-for="item in pLanguages">{{item}}</li>
                </ul>
            </slot>
        </div>
    </template>

    <script src="../js/vue.js"></script>
    <script>
        const app = new Vue({
            el: '#app',
            data: {

            },
            components: {
                cpn: {
                    template: '#cpn',
                    data() {
                        return {
                            pLanguages: ['JavaScript', 'Java', 'C++', 'C#', 'Python', 'C']
                        }
                    }
                }
            }
        })
    </script>
</body>

实行结果：

・JavaScript
・Java
・C++
・C#
・Python
・C

JavaScript - Java - C++ - C# - Python - C
JavaScript * Java * C++ * C# * Python * C
```
## 14. 模块化开发
### 14.1 简介
常见的模块化规范：`CommonJS`，`AMD`，`CMD`，`Modules(ES6)` <br/>
- 模块化有两个核心：导入和导出
- `CommonJS`的导出
```
module.exports = {
    flag: true,
    test(a, b){
        return a + b
    },
    demo(a, b){
        return a * b
    }
}
```
- `CommonJS`的导入
```
//CommonJS模块
let { test, demo, flag } = require('moduleA');

//等同于
let _mA = require('moduleA');
let test = _mA.test;
let demo = _mA.demo;
let flag = _mA.flag;
``` 
### 14.2 ES6模块化的导入和导出
- `export`导出
  - 导出模块对外提供的接口
  - 首先我们需要在HTML代码中引入js文件，并且类型需要设置为`module`
    - `<script src="info.js" type="module"></script>`
- `import`导入
  - 用于导入模块中的内容
```
import {name, age, height} from "./info.js"
console.log(name, age, height);
```
  - 如果我们希望某个模块中所有的信息都导入，一个个导入显然很麻烦
  - 通过`*`可以导入模块中所有的`export`变量
  - 但是通常情况下，我们需要给`*`起一个别名，方便后续的使用
```
import * as info form './info.js'
console.log(info.name, info.age, info.friends);
```
- `export default`
  - 某些情况下，一个模块中包含某个功能，我们并不希望给这个功能命名，而是让导入者可以自己来命名
  - 在同一个模块中，不允许同时存在多个`export default`
``` 
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES6模块化</title>
</head>
<body>
    <!-- 导入模块需要加上type="module" -->
    <script src="a.js" type="module"></script>
    <script src="b.js" type="module"></script>
    <script src="c.js" type="module"></script>
</body>
</html>
```
```
// a.js文件

var name = '孙悟空'
var age = 18
var flag = true

var sum = function (sum1, sum2) {
    return sum1 + sum2
}

//1. 导出方式一
export {
    name,
    sum,
    flag
}

//2. 导出方式二
export var num1 = 1000;
export var num2 = 2000

//3. 导出函数/类
export function mul(num1, num2) {
    return num1 * num2
}

export class Person {
    run() {
        console.log('在奔跑')
    }
}

//4. 导出default
// export default在同一个模块中，不允许同时存在多个

/*
const address = '北京市'
export default address
*/

export default function (argument) {
    console.log(argument);
}
```
```
// b.js 文件

// 导入a.js中的sum
import {
    sum
} from './a.js'

var name = '猪八戒'
var age = 28
var flag = false

console.log(sum(100, 200)) //300

// 直接导入export定义的变量
import {
    num1,
    num2
} from './a.js'

console.log(num1 + num2) //3000

// 导入export的function
import {
    mul,
    Person
} from './a.js';

console.log(mul(30, 50)); // 1500

const p = new Person();
p.run() //在奔跑

// 导入export中的address
/*
import addr from './a.js';
console.log(addr); //北京市
*/

//导入的是export default，所以导入的时候函数名字可以随便取 
import hi from './a.js';
hi('Hello') //Hello

//统一全部导入
import * as info from './a.js';
console.log(info.flag); //true
console.log(info.name); //孙悟空
console.log(sum(30, 90));//120
``` 
```
// c.js文件

// 导入a.js中的name，flag和sum
import {
    name,
    flag,
    sum
} from "./a.js"

if (flag) {
    console.log(name); //孙悟空
    console.log(sum(20, 30)) //50
}
```
```
实行结果：
300
3000
1500
在奔跑
Hello
true
孙悟空
120
孙悟空
50 
```
## 15. `webpack`
### 15.1 介绍
从本质上来将，`webpack`是一个现代的JavaScript应用的静态模块打包工具。<br/>
`webpack`的一个核心就是可以让我们进行模块化开发，并会帮助我们处理模块间的依赖关系。<br/>
而且不仅仅是JavaScript文件，CSS，图片，json文件等等在`webpack`中都可以被当做模块来使用。<br/>
- `grunt/gulp`的核心是`Task`
  - 我们可以配置一系列的`task`，并且定义`task`要处理的事务(例如ES6，ts转化，图片压缩，sass装成css)
  - 之后让`grunt/gulp`来依次执行这些`task`，而且让整个流程自动化
  - 所以`grunt/gulp`也被称为前端自动化任务管理工具
- `webpack`和`grunt/gulp`的应用
  - 如果我们的工程模块依赖非常简单，甚至是没有用到模块化的概念
  - 只需要进行简单的合并，压缩，就使用`grunt/gulp`即可
  - 但是如果整个项目使用了模块化管理， 而且相互依赖非常强，我们就可以使用`webpack`
- `webpack`和`grunt/gulp`的不同
  - `grunt/gulp`更加强调的是前端流程的自动化，模块化不是它的核心
  - `webpack`更加强调模块化开发管理，而文件压缩合并，预处理等功能，是它附带的功能
### 15.2 安装
- <https://www.bilibili.com/video/BV15741177Eh?p=76>
- `webpack`为了正常运行，必须依赖`node`环境
- `node`环境为了可以正常的执行很多代码，其中必须包含各种依赖的包
- 为了管理各种包，又引入了`npm(node packages manager)`工具，来管理各种依赖的包
- 安装`webpack`首先需要安装`Node.js`，`Node.js`自带了软件包管理工具npm
### 15.3 基本使用过程
<https://www.bilibili.com/video/BV15741177Eh?p=77>
### 15.4 webpack.config.js配置和package.json配置
<https://www.bilibili.com/video/BV15741177Eh?p=78>
### 15.5 `webpack`中使用`css`文件的配置：`loader`
- `loader`是`webpack`中的一个非常核心的概念。 <br/>
- `webpack`用来做什么呢？ 
  - 在之前的实例中，主要是用`webpack`来处理我们写的`js`代码，并且`webpack`会自动处理`js`之间相关的依赖
  - 但是，在开发中我们不仅仅有基本的`js`代码处理，
  - 我们也需要加载`css`，图片，也包括一些高级的将`ES6`转成`ES5`代码
  - 将`TypeScript`转成`ES5`代码，将`sass`，`less`转成`css`，将`.jsx`(react的文件),`.vue`文件转成`js`文件等等
  - 对于`webpack`本身的能力来说，对于这些转化是不支持的
  - 那怎么办呢？给`webpack`扩展对应的`loader`就可以了
- `loader`使用过程
  - 步骤一：通过`npm`安装需要使用的`loader`：`npm install --save-dev css-loader`
    - 如果安装`css-loader`时，报错`TypeError: this.getResolve is not a function at Object.loader`
    - 以上报错，说明`css-loader`版本过高`npm install --save-dev css-loader@2.0.2`
    - 解决方法(降低版本)：
  - 步骤二：在`webpack.config.js`中的`module`关键字下进行配置
```
module: {
        rules: [
            {
                test: /\.css$/,
                // css-loader只负责将css文件进行加载
                // style-loader负责将样式添加到DOM中
                // 使用多个loader时，是从右到左读取的
                use: ['style-loader','css-loader']
            }
        ]
}
```
- 大部分`loader`我们都可以在`webpack`的官网中找到，并且学习对应的用法
  - 英文官网：<https://webpack.js.org/>
  - 中文官网：<https://www.webpackjs.com/>
### 15.6 `webpack`-`less`文件的处理
- 如果我们希望在项目中使用`less`，`sass`，`stylus`来写样式，`webpack`也是可以帮我们处理的。
- 步骤一：通过`npm`安装需要使用的`loader`：`npm install --save-dev less-loader less`
- 步骤二：在`webpack.config.js`中的`module`关键字下进行配置
```
module: {
        rules: [
            {
                test: /\.css$/,
                // css-loader只负责将css文件进行加载
                // style-loader负责将样式添加到DOM中
                // 使用多个loader时，是从右到左读取的
                use: ['style-loader', 'css-loader']
            },
            {
                test: /\.less$/,
                use: [{
                    loader: "style-loader" // creates style nodes from JS strings
                }, {
                    loader: "css-loader" // translates CSS into CommonJS
                }, {
                    loader: "less-loader" // compiles Less to CSS
                }]
            }
        ]
    }
```
### 15.7 `webpack`-图片文件的处理
<https://www.bilibili.com/video/BV15741177Eh?p=81>

### 15.8 `webpack`-`ES6`转`ES5`的babel
<https://www.bilibili.com/video/BV15741177Eh?p=82>

### 15.9 `webpack`-使用`Vue`的配置过程
<https://www.bilibili.com/video/BV15741177Eh?p=83>

### 15.10 创建Vue时`template`和`el`关系
<https://www.bilibili.com/video/BV15741177Eh?p=84>

### 15.11 Vue的终极使用方案
```
<!-- index文件 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>index</title>
</head>
<body>
    <div id="app">
    </div>
    <script src="./dist/bundle.js"></script>
</body>
</html>
```
```
// main.js文件
// 1. 使用CommonJS的模块化规范
const { add, mul } = require('./js/mathUtils.js')

console.log(add(20, 30));
console.log(mul(20, 30));

//2. 使用ES6的模块化规范
import { name, age, height } from './js/info';
console.log(name);
console.log(age);
console.log(height);

//3. 依赖css文件
require('./css/normal.css')

//4. 依赖less文件 
require('./css/special.less')
document.writeln('<h2>Hello! Today is a nice day!</h2>')

//5. 使用Vue进行开发
import Vue from 'vue'
// import App from './vue/app'
import App from './vue/App.vue'

new Vue({
    el: '#app',
    template: `<App/>`,
    components: {
        App
    }
})
```
```
// App.vue
<template>
  <div>
    <h2 class="title">{{ message }}</h2>
    <button @click="btnClick">按钮</button>
    <h2>{{ name }}</h2>
    <Cpn/>
  </div>
</template>

<script>
import Cpn from "./Cpn";
export default {
  name: "App",
  components: {
    Cpn
  },
  data() {
    return {
      message: "Hello Vue!!!",
      name: "Jame",
    };
  },
  methods: {
    btnClick() {},
  },
};
</script>

<style scoped>
.title {
  color: yellow;
}
</style>
```
```
// Cpn.vue
<template>
  <div>
    <h2 class="title">我是Cpn组件的标题</h2>
    <p>我是Cpn组件的内容</p>
    <h2>{{ name }}</h2>
  </div>
</template>

<script>
export default {
  name: "Cpn",
  data() {
    return {
      name: "Cpn组件的name",
    };
  },
};
</script>

<style scoped>
.title {
  color: red;
}
</style>
```
```
// webpack.config.js
const path = require('path')

module.exports = {
    entry: './src/main.js',
    output: {
        // 动态获取绝对路径：用nodejs的知识
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js',
        // 所有的url都会添加上dist/
        publicPath: 'dist/'
    },
    // webpack加载css文件
    module: {
        rules: [
            {
                test: /\.css$/,
                // css-loader只负责将css文件进行加载
                // style-loader负责将样式添加到DOM中
                // 使用多个loader时，是从右到左读取的
                use: ['style-loader', 'css-loader']
            },
            {
                test: /\.less$/,
                use: [{
                    loader: "style-loader" // creates style nodes from JS strings
                }, {
                    loader: "css-loader" // translates CSS into CommonJS
                }, {
                    loader: "less-loader" // compiles Less to CSS
                }]
            },
            {
                test: /\.(png|jpg|gif|jpeg)$/,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            // 当加载的图片，小于limit时，会将图片编译成base64字符串形式
                            // 当加载的图片，大于limit时，需要使用file-loader模块进行加载
                            // 此时再进行打包的时候，图片会在dist文件夹中生成
                            // 浏览器显示的时dist生成的图片，所以需要在现在的文件中，加上第10行的代码
                            // limit: 8192
                            limit: 10000,
                            // 对图片按以下规范进行命名
                            name: 'img/[name].[hash:8].[ext]'
                        }
                    }
                ]
            },
            {
                test: /\.js$/,
                // exclude:排除
                exclude: /(node_modules|bower_components)/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['es2015']
                    }
                }
            },
            {
                test: /\.vue$/,
                use: {
                    loader: 'vue-loader'
                }
            }
        ]
    },
    resolve: {
        // 引入以下扩展名的文件时，可以省略以下扩张子
        extensions: ['.js', '.css', '.vue'],
        // alias:别名
        alias: {
            'vue$': 'vue/dist/vue.esm.js'
        }
    }
}
```
```
// package.json
{
  "name": "meetwebpack",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "babel-core": "^6.26.3",
    "babel-loader": "^7.1.5",
    "babel-preset-es2015": "^6.24.1",
    "css-loader": "^2.0.2",
    "file-loader": "^3.0.1",
    "less": "^4.0.0",
    "less-loader": "^4.1.0",
    "style-loader": "^2.0.0",
    "url-loader": "^1.1.2",
    "vue-loader": "^13.0.0",
    "vue-template-compiler": "^2.6.12",
    "webpack": "^3.6.0"
  },
  "dependencies": {
    "vue": "^2.6.12"
  }
}
```
### 15.12 `webpack`-横幅`Plugin`的使用
#### 15.12.1 `Plugin`
- `Plugin`是什么？
  - `Plugin`是插件的意思，通常是用于对某个现有的架构进行扩展
  - `webpack`中的插件，就是对`webpack`现有功能的各种扩展，比如打包优化，文件压缩等等
- `loader`和`Plugin`的区别
  - `loader`主要用于转换某些类型的模块，它是一个转换器
  - `Plugin`是插件，它是对`webpack`本身的扩展，是一个扩展器
- `Plugin`的使用过程
  - 步骤一：通过`npm`安装需要使用的`plugins`(某些`webpack`已经内置的插件不需要安装)
  - 步骤二：在`webpack.config.js`中的`plugins`中配置插件
#### 15.12.2 添加版权的`Plugin`
首先使用一个最简单的插件，为打包的文件添加版权声明 <br/>
该插件的名字叫`BannerPlugin`，属于`webpack`自带的插件 <br/>
按照下面的方式来修改`webpack.config.js`的文件 <br/>
```
const path = require('path')
const webpack = require('webpack')

module.exports = {
    ...
    plugins: [
        new webpack.BannerPlugin('最终版权归Jame所有')
    ]
}
```
重新打包程序：查看bundle.js文件的头部，看到如下信息
```
/*! 最终版权归Jame所有 */
/******/ (function(modules) { // webpackBootstrap
```
### 15.13 `webpack`-`HtmlWebPackPlugin`的使用
- 目前，我们的`index.html`文件是存放在项目的根目录下的。
  - 在真实发布项目时，发布的是dist文件夹中的内容，
  - 但是dist文件中如果没有`index.html`文件，那么打包的js等文件就没有意义了
  - 所以，我们需要将`index.html`文件打包到dist文件夹中，这个时候就可以使用`HtmlWebPackPlugin`插件
- `HtmlWebPackPlugin`插件可以为我们做以下事情
  - 自动生成一个`index.html`文件(可以指定模版来生成)
  - 将打包的js文件，自动通过`script`标签插入到`body`中
- 安装`HtmlWebPackPlugin`插件
```
npm install html-webpack-plugin --save-dev
```
- 使用插件，修改`webpack.config.js`文件中`plugins`部分的内容如下：
  - 这里的`template`表示根据什么模版生成`index.html`
  - 另外，我们需要删除之前在`output`中添加的`publicPath`属性
  - 否则插入的`script`标签中的scr可能会有问题
```
const HtmlWebpackPlugin = require('html-webpack-plugin')
plugins: [
    new webpack.BannerPlugin('最终版权归Jame所有'),
    new HtmlWebpackPlugin({
        template: 'index.html'
    })
]
```
### 15.14 `webpack`-`UglifyjsWebpackPlugin`的使用
`js`压缩的`Plugin` <br/>
- 在项目发布之前，我们必要需要对`js`等文件进行压缩处理
  - 这里，我们就对打包的js文件进行压缩
  - 我们使用一个第三方的插件`uglifyjs-webpack-plugin`，并且版本指定`1.1.1`，和`CLI2`保持一致
```
npm install uglifyjs-webpack-plugin@1.1.1 --save-dev
```
- 修改`webpack.config.js`文件，使用插件
```
const uglifyJsPlugin = require('uglifyjs-webpack-plugin')

module.exports = {
    ...
    new uglifyJsPlugin()
}
```
- 查看打包后的`bunlde.js`文件，是已经被压缩过了
### 15.15 `webpack`-`dev-server`搭建本地服务器
- `webpack`提供了一个可选的本地开发服务器，这个本地服务器基于`node.js`搭建，内部使用`express`框架，
  - 可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。
- 不过它是一个单独的模块，在webpack中使用之前，需要先安装它。
```
npm install --save-dev webpack-dev-server@2.9.1
```
- `deserver`也是作为`webpack`中的一个选项，选项本身可以设置如下属性：
  - `contentBase`：为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写`./dist`
  - `port`：端口号
  - `inline`：页面实时刷新
  - `historyApiFallback`：在SPA页面中，依赖HTML5的`history`模式
- `webpack.config.js`文件配置修改如下
```
devServer: {
    contentBase: './dist',
    inline: true
},
```
- 我们可以再配置另外一个script
  - `--open`参数表示直接打开浏览器
```
<!-- package.json -->
"scripts": {
    ...
    "dev": "webpack-dev-server --open"
  },
```
- 实行时，在控制台输入如下代码
```
npm run dev
```
### 15.16 `webpack`-配置文件(`webpack.config.js`)的分离
- 配置文件分离
  - 将`webpack.config.js`分离成三个配置文件
    - 共用配置文件：`base.config.js`
    - 开发配置文件：`dev.config.js`
    - 生产配置文件：`prod.config.js`
- 安装`webpack-merge`
```
npm install webpack-merge@4.1.5 --save-dev
```
- 修改`package.json`文件
```
//package.json
"scripts": {
    ...
    "build": "webpack --config ./build/prod.config.js",
    "dev": "webpack-dev-server --open --config ./build/dev.config.js"
  },
```
- 修改`base.config.js`文件中的路径，以使dist文件在项目直下的dist里面
```
path: path.resolve(__dirname, '../dist'),
```
## 16. `Vue CLI`
### 16.1 介绍
- 如果你只是简单写几个`Vue`的`Demo`程序，那么你不需要`Vue CLI`
- 如果你在开发大型项目，那么你必然需要使用`Vue CLI`
  - 使用`Vue.js`开发大型应用时，我们需要考虑代码目录结构，项目结构和部署，热加载，代码单元测试等
  - 如果每个项目都要手动完成这些工作，那么无疑效率比较低效，所以通常我们会使用一些脚手架工具来帮助完成
- `CLI`是什么意思？
  - `CLI`是`Command-Line Interface`，翻译为命令行界面，但是俗称脚手架
  - `Vue CLI`是一个官方发布`vue.js`项目脚手架
  - 使用`vue-cli`可以快速搭建`Vue`开发环境以及对应的`webpack`配置
### 16.2 `Vue CLI`的使用前提-`Node`
- 安装`NodeJS`
  - 网址：<http://nodejs.cn/download/>
- 检测安装的版本
  - 默认情况下自动安装`Node`和`NPM`
  - `Node`环境要求8.9以上或者更高版本
  - 查看版本：`node -v`
- 什么是`NPM`呢？ 
  - `NPM`的全称是`Node Package Manager`
  - 是一个`NodeJS`包管理和分发工具，已经成为了非官方发布`Node`模块的标准
  - 后续我们会经常使用NPM来安装一些开发过程中依赖包
- `Vue.js`官方脚手架工具就使用了`webpack`模版
  - 对所有的资源会压缩等优化操作
  - 它在开发过程中提供了一套完整的功能，能够使得我们在开发过程中变得更加高效
- `Webpack`的全局安装
```
npm install webpack -g
```
### 16.3 `Vue CLI`的使用
- 安装`Vue`脚手架
```
npm install -g @vue/cli
```
- 如果需要安装指定版本(比如:`3.2.1`)的脚手架，则需要执行以下代码
```
npm install -g @vue/cli@3.2.1
```
- 查看脚手架的版本
```
vue --version
```
- 如果我们既想使用`Vue CLI3`，又想使用`Vue CLI2`。则可以拉取`2.x`模版(旧版本)
  - `Vue CLI3`和旧版使用了相同的`vue`命令，所以`Vue CLI2`被覆盖了。
  - 如果你仍然需要使用旧版本的`vue init` 功能，你可以全局安装一个桥接工具
```
npm install -g @vue/cli-init
# `vue init`的运行效果将会跟`vue-cli@2.x`相同
vue init webpack my-project
```
- `Vue CLI2`初始化项目
```
vue init webpack my-project
```
- `Vue CLI3`初始化项目
```
vue create my-project
```
### 16.4 `Vue CLI2`初始化项目过程
<https://www.bilibili.com/video/BV15741177Eh?p=92>

### 16.5 `Vue CLI2`的目录结构解析
<https://www.bilibili.com/video/BV15741177Eh?p=93>

### 16.6 `runtime-compile`和`runtime-only`的区别
- `runtime-compile`：template -> ast -> render -> vdom -> UI
  - 如果在之后的开发中，依然使用`template`，就需要选择`runtime-compile`
- `runtime-only`：render ->vdom -> UI
  - 如果在之后的开发中，使用的是`.vue`文件夹开发，那么可以选择`runtime-only`
  - 性能更高
  - 代码量少
- 知识补充
  - `createElement`的用法
    - 普通用法： `createElement('标签',{标签的属性},[''])`
      - 例：`createElement('h2',{class:'box'},['Hello World'])`
    - 传入组件对象：`createElement(cpn)`
      - 例：
```
const cpn = {
    template: '<div>{{message}}</div>',
    data() {
        return {
            message: '我是组件message'
        }
    }
}
new Vue({ 
    el: '#app',
    render: function(createElement) {
        return createElement(cpn)
    }
})
```
### 16.7 `VueCLI3`创建项目和目录结构
#### 16.7.1 `vue-cli3`和`vue-cli2`的区别
- `vue-cli3`是基于`webpack4`打造，`vue-cli2`是基于`webpack3`打造
- `vue-cli3`的设计原则是`0配置`，移除的配置文件根目录下的`build`和`config`等目录
- `vue-cli3`提供了`vue ui`命令，提供了可视化配置，更加人性化
- 移除了`static`文件夹，新增了`public`文件夹，并且`index.html`移动到`public`中
#### 16.7.2 创建`VueCLI3`
- 创建`VueCLI3`：`vue create 项目名称`
- 运行`VueCLI3`：`npm run serve`
#### 16.7.3 `VueCLI3`配置文件的查看和修改
- UI方面的配置
  - 启动配置服务器：`vue ui`
## 17. 箭头函数的使用和`this`指向
### 17.1 基本使用
箭头函数是一种定义函数的方式。<br/>
- 定义函数的方式：`function`
```
const fun = function(){

}
```
- 对象字面量中定义函数
```
const obj = {
    fun1: function(){

    },
    fun2(){

    }
}
```
- ES6中的箭头函数
  - `const fun3 = (参数列表) => {}`
```
const fun3 = () => {

}
```
### 17.2 箭头函数的参数和返回值
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>箭头函数的参数和返回值</title>
</head>
<body>
    <script>
        // 1. 参数问题
        // 1.1 两个参数
        const sum = (num1, num2) => {
            return num1 + num2
        }
        // 1.2 一个参数：小括号可以省略
        const power = num => {
            return num * num
        }

        // 2. 函数中的行数问题
        // 2.1 函数代码中有多行代码时
        const test = () => {
            console.log("Hello World");
            console.log("Hello Vuejs");
        }

        // 2.2 函数代码中只有一行代码时
        /*
        const mul = (num1, num2) => {
            return num1 * num2
        }
        */
        const mul = (num1, num2) => num1 * num2
    </script>
</body>
</html>
```
### 17.3 箭头函数`this`的使用
- 箭头函数中的`this`是如何查找的呢？
  - 箭头函数中的`this`引用的就是离它最近作用域中的`this`
```
const obj = {
    fun() {
        setTimeout(function () {
            console.log(this); // window
        }) 
        setTimeout(() => {
            console.log(this); // obj对象
        })
    }
}
obj.fun();
```
## 18. 路由
### 18.1 什么是路由
- 路由器提供了两种机制：路由和转送
  - 路由是决定数据包从来源到目的地的路径
  - 传送将输入端的数据转移到合适的输出端
- 路由中有个非常重要的概念叫做路由表
  - 路由表本质上就是一个映射表，决定了数据包的指向
### 18.2 前端路由
- SPA(单页面富应用阶段)
  - SPA最主要的特点就是在前后端分离的基础上加了一层前端路由
  - 也就是前端来维护一套路由规则
- 前端路由的核心是什么
  - 改变URL，但是页面不进行整体的刷新
### 18.3 URL的`hash`和HTML5的`history`
改变URL，但是页面不进行整体刷新的方法有两种：<br/>
#### 18.3.1 使用URL的`hash`
  - URL的`hash`也就是锚点(#)，本质上是改变`window.location`的`href`属性
  - 我们可以通过直接赋值`location.hash`来改变`href`，但是页面不发生刷新
```
> location.hash = '/foo'
```
#### 18.3.2 使用HTML5的`history`模式
- `pushState`
```
// 入栈
> history.pushState({},'','home')
```
- `back`
```
// 出栈
> history.back() //返回上一页
```
- `replaceState` 
  - 不会遗留历史数据
```
> history.replaceState({},'','home')
```
- `go`
```
> history.pushState({},'','home')
> history.pushState({},'','about')
> history.pushState({},'','me')
> history.pushState({},'','demo')
> history.pushState({},'','test')

> history.go(-1) // 等同于history.back() 显示的是：demo
> history.go(-2) // 等同于history.back() 显示的是：about
> history.go(2) // 等同于history.back() 显示的是：demo
```
- 补充
  - `history.back()`等价于`history.go(-1)`
  - `history.forward()`等价于`history.go(1)`
### 18.4 `vue-router`安装和配置方式
#### 18.4.1 三大框架的路由
目前前端流行的三大框架，都有自己的路由实现：<br/>
- `Angular`的`ngRouter`
- `React`的`ReactRouter`
- `Vue`的`vue-router`
#### 18.4.2 `vue-router`介绍
- `vue-router`是`Vue.js`官方的路由插件，它和`vue.js`是深度集成的，适合于构建单页面应用
- 可以访问其他官方网站对其进行学习：<https://router.vuejs.org/zh/>
- `vue-router`是基于路由和组件的
  - 路由用于设定访问路径，将路径和组件映射起来
  - 在`vue-router`的单页面应用中，页面的路径的改变就是组件的切换
#### 18.4.3 `vue-router`的安装
- 步骤一：直接使用`npm`来安装路由即可
  - 安装`vue-router`：`npm install vue-router --save`
- 步骤二：在模块化工程中使用它(因为是一个插件，所以可以通过`Vue.use()`来安装路由功能)
  - 第一步：导入路由对象，并且调用`Vue.use(VueRouter)`
  - 第二步：创建路由实例，并且传入路由映射配置
  - 第三部：在`Vue`实例中挂载创建的路由实例
- 使用`vue-router`的步骤
  - 第一步：创建路由组件
  - 第二步：配置路由映射：组件和路径映射关系
  - 第三步：使用路由
    - 通过`<router-link>`和`<router-view>`
```
// index.js 文件

import Vue from 'vue'
// 配置路由相关信息
import Router from 'vue-router'

// 导入要使用的组件
import Home from '../components/Home'
import About from '../components/About'

// 1. 通过Vue.use(插件)，安装插件
Vue.use(Router)

// 2. 创建VueRouter对象
export  default new Router({
  // 配置路由和组件之间的映射关系
  routes: [
    {
      path:'/home',
      component:Home
    },
    {
      path:'/about',
      component:About
    }
  ]
})
```
```
//Home.vue

<template>
  <div>
    <h2>我是首页</h2>
    <p>我是首页的内容</p>
  </div>
</template>

<script>
export default {
  name: "Home",
};
</script>
 
<style scoped>
</style>
```
```
//About.vue

<template>
  <div>
    <h2>我是相关信息</h2>
    <p>我是相关信息的内容</p>
  </div>
</template>

<script>
export default {
  name: "About",
};
</script>

<style scoped>
</style>
```
```
//App.vue文件

<template>
  <div id="app">
    <router-link to="/home">首页</router-link>
    <router-link to="/about">关于</router-link>
    <router-view></router-view>
  </div>
</template>

<script>
export default {
  name: 'App'
}
</script>

<style>
</style>
```
```
// main.js

import Vue from 'vue'
import App from './App'
import router from './router'

Vue.config.productionTip = false

/* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  render: h => h(App)
})
```
- 设置路由的默认路径
```
//index.js

// 2. 创建VueRouter对象 
export  default new Router({
  // 配置路由和组件之间的映射关系
  routes: [
    {
      //redirect(重定向)：设置默认路径
      path:'',
      redirect:'/home'
    },
    {
      path:'/home',
      component:Home
    },
    {
      path:'/about',
      component:About
    }
  ],
  //将URL hash模式改为History模式
  mode: 'history' 
})
```
### 18.5 `router-link`属性补充
- `to`：用于指定跳转的路径
- `tag`：可以指定`<router-link>`之后渲染成什么组件
```
//将组件渲染成button属性
<router-link to="/home" tag="button">首页</router-link>
<router-link to="/about" tag="button">关于</router-link>
```
- `replace`：不会留下`history`记录，所以指定`replace`的情况下，后退键返回不能返回上一个页面中
```
<router-link to="/home" tag="button" replace>首页</router-link>
<router-link to="/about" tag="button" replace>关于</router-link>
```
- `active-class`：当`<router-link>`对应的路由配对成功时，会自动给当前元素设置一个`router-link-active`的`class`
- 设置`active-class`可以修改默认的名称
  - 在进行高亮显示的导航菜单或者底部`tabbar`时，会使用到该类
  - 但是通常不会修改类的属性，会直接使用默认的`router-link-active`即可
```
//点击按钮，elements会显示对应的类

<style>
.router-link-active{
  color: tomato;
}
</style>
```
```
// 如果以上router-link-active类名感觉过于繁琐，可以自己对其进行修改
// 将router-link-active修改为active
// index.js文件

import Vue from 'vue'
// 配置路由相关信息
import Router from 'vue-router'

// 导入要使用的组件
import Home from '../components/Home'
import About from '../components/About'

// 1. 通过Vue.use(插件)，安装插件
Vue.use(Router)

// 2. 创建VueRouter对象
export default new Router({
  // 配置路由和组件之间的映射关系
  routes: [
    {
      //redirect：重定向
      path: '',
      redirect: '/home'
    },
    {
      path: '/home',
      component: Home
    },
    {
      path: '/about',
      component: About
    }
  ],
  //将URL hash模式改为History模式
  mode: 'history',
  linkActiveClass: 'active'
})
```
```
//App.vue文件

<template>
  <div id="app">
    <h2>我是APP组件</h2>
    <router-link to="/home" tag="button" replace>首页</router-link>
    <router-link to="/about" tag="button" replace>关于</router-link>
    <router-view></router-view>
  </div>
</template>

<script>
export default {
  name: 'App'
}
</script>

<style>
.active{
  color: tomato;
}
</style>
```
### 18.6 通过代码跳转路由
```
//App.vue文件

<template>
  <div id="app">
    <h2>我是APP组件</h2>
    <!-- <router-link to="/home" tag="button" replace>首页</router-link> -->
    <!-- <router-link to="/about" tag="button" replace>关于</router-link> -->
    <button @click="homeClick">首页</button>
    <button @click="aboutClick">关于</button>
    <router-view></router-view>
  </div>
</template>

<script>
export default {
  name: "App",
  methods: {
    homeClick() { 
      // 通过代码的方式修改路径
      // this.$router.push('/home');
      this.$router.replace('/home');
      console.log("homeClick");
    },
    aboutClick() {
      // 通过代码的方式修改路径
      // this.$router.push('/about');
      this.$router.replace('/about');
      console.log("aboutClick");
    },
  },
};
</script>

<style>
.active {
  color: tomato;
}
</style>
```
### 18.7 动态路由的使用
- 实例：URL中，除了`user`外，还需要动态生成`userId`。
- 比如：`http://localhost:8081/user/Tom`
```
// 组件：User.vue文件

<template>
  <div>
    <h2>我是用户界面</h2>
    <p>我是用户信息</p>
    <!-- 第一种方式：在网页中显示userId -->
    <h2>{{ userId }}</h2>
    <!-- 第二种方式：在网页中显示userId -->
    <h2>{{ $route.params.userId }}</h2>
  </div>
</template>

<script>
export default {
  name: "User",
  computed: {
    userId() {
      // 处于当前活跃状态的route
      return this.$route.params.userId;
    },
  },
};
</script>
<style scoped>
</style>
```
```
// index.js文件

import Vue from 'vue'
// 配置路由相关信息
import Router from 'vue-router'

// 导入要使用的组件
import Home from '../components/Home'
import About from '../components/About'
import User from '../components/User'

// 1. 通过Vue.use(插件)，安装插件
Vue.use(Router)

// 2. 创建VueRouter对象
export default new Router({
  // 配置路由和组件之间的映射关系
  routes: [
    {
      //redirect：重定向
      path: '',
      redirect: '/home'
    },
    {
      path: '/home',
      component: Home
    },
    {
      path: '/about',
      component: About
    },
    {
      path: '/user/:userId',
      component: User
    }
  ],
  //将URL hash模式改为History模式
  mode: 'history',
  // 将class重新命名为active 
  linkActiveClass: 'active'
})
```
```
// App.vue文件

<template>
  <div id="app">
    <h2>我是APP组件</h2>
    <!-- <router-link to="/home" tag="button" replace>首页</router-link> -->
    <!-- <router-link to="/about" tag="button" replace>关于</router-link> -->
    <!-- <button @click="homeClick">首页</button> -->
    <!-- <button @click="aboutClick">关于</button> -->
    <router-link to="/home">首页</router-link>
    <router-link to="/about">关于</router-link>
    <router-link :to="'/user/' + userId">用户</router-link>

    <router-view></router-view>
  </div>
</template>

<script>
export default {
  name: "App",
  data() {
    return {
      userId: "Tom",
    };
  },
  methods: {
    homeClick() {
      // 通过代码的方式修改路径
      // this.$router.push('/home');
      this.$router.replace("/home");
      console.log("homeClick");
    },
    aboutClick() {
      // 通过代码的方式修改路径
      // this.$router.push('/about');
      this.$router.replace("/about");
      console.log("aboutClick");
    },
  },
};
</script>

<style>
.active {
  color: tomato;
}
</style>
```
### 18.8 路由懒加载的使用
#### 18.8.1 由来
- 首先，我们知道路由中通常定义很多不同的页面
- 这个页面最后被打包在一个js文件中
- 但是，页面这么多放在一个js文件中，必然会造成这个页面非常的大
- 如果我们一次性从服务器请求下来的页面，可能需要花费一定的时间
- 甚至用户的电脑上还出现了短暂空白的情况
- 可以使用路由懒加载来避免这种情况
#### 18.8.2 作用
- 路由懒加载的主要作用就是将路由对应的组件打包成一个个的`js`代码块
- 只有在这个路由被访问到的时候，才加载对应的组件
#### 18.8.3 效果
- 不使用懒加载，打包时会将代码打包到一个`js`文件里面
```
import Home from '../components/Home'
import Home from '../components/About'

Vue.use(VueRouter);

const routes = [
    {
        path: '/home',
        component: Home
    },
    {
        path: 'about',
        component: About
    },
];
```
- 使用懒加载，打包时会将代码打包成一个个的`js`文件
```
const routes = [
    {
        path: '/home',
        component: () => import('../components/Home')
    },
    {
        path: 'about',
        component: () => import('../components/About')
    },
];
```
#### 18.8.4 懒加载的方式
- 方式一：结合`Vue`的异步组件和`Webpack`的代码分析
```
const Home = resolve => {
    require.ensure(
        ['../components/Home.Vue'],() => {
            resolve(require('../components/Home.vue'))
        }
    )
};
```
- 方式二：`AMD`写法
```
const About = resolve => require(['../components/About.vue'],resolve)
```
- 方式三：在ES6中，我们可以有更加简单的写法来组织`Vue`异步组件和`Webpack`的代码分割
```
const Home = () => import('../components/Home.vue')
```
```
import Vue from 'vue'
// 配置路由相关信息
import Router from 'vue-router'

// 导入要使用的组件
// import Home from '../components/Home'
// import About from '../components/About'
// import User from '../components/User'

// 懒加载
const Home = () => import('../components/Home')
const About = () => import('../components/About')
const User = () => import('../components/User')

// 1. 通过Vue.use(插件)，安装插件
Vue.use(Router)

// 2. 创建VueRouter对象
export default new Router({
  // 配置路由和组件之间的映射关系
  routes: [
    {
      //redirect：重定向
      path: '',
      redirect: '/home'
    },
    {
      path: '/home',
      component: Home
    },
    {
      path: '/about',
      component: About
    },
    {
      path: '/user/:userId',
      component: User
    }
  ],
  //将URL hash模式改为History模式
  mode: 'history',
  // 将class重新命名为active 
  linkActiveClass: 'active'
})
``` 
### 18.9 路由的嵌套使用
- 嵌套路由是一个很常见的功能
  - 比如在home页面中，我们希望通过/home/news和/home/message访问一些内容
  - 一个路径映射一个组件，访问这两个路径也会分别渲染两个组件
- 实现嵌套由两个步骤
  - 创建对应的子组件，并且在路由映射中配置对应的子路由
  - 在组件内部使用`<router-view>`标签
- 实例：在`home`主页中创建`home/news`和`home/message`
```
//HomeNews.vue

<template>
<div>
    <ul>
        <li>新闻1</li>
        <li>新闻2</li>
        <li>新闻3</li>
        <li>新闻4</li>
    </ul>
</div>
</template>

<script>
export default {
  name: "HomeNews",
};
</script>

<style scoped>
</style>
```
```
//HomeMessage.vue

<template>
<div>
    <ul>
        <li>消息1</li>
        <li>消息2</li>
        <li>消息3</li>
        <li>消息4</li>
    </ul>
</div>
</template>

<script>
export default {
  name: "HomeMessage",
};
</script>

<style scoped>
</style>
```
```
//index.js

import Vue from 'vue'
// 配置路由相关信息
import Router from 'vue-router'

// 导入要使用的组件
// import Home from '../components/Home'
// import About from '../components/About' 
// import User from '../components/User'

// 路由懒加载
const Home = () => import('../components/Home')
const HomeNews = () => import('../components/HomeNews')
const HomeMessage = () => import('../components/HomeMessage')
const About = () => import('../components/About')
const User = () => import('../components/User')

// 1. 通过Vue.use(插件)，安装插件
Vue.use(Router)

// 2. 创建VueRouter对象
export default new Router({
  // 配置路由和组件之间的映射关系 
  routes: [
    {
      //redirect：重定向
      path: '',
      redirect: '/home',
    },
    {
      path: '/home',
      component: Home,
      children: [
        {
          path: '',
          redirect: 'news'
        },
        {
          path: 'news',
          component: HomeNews
        },
        {
          path: 'message',
          component: HomeMessage
        }
      ]
    },
    {
      path: '/about',
      component: About
    },
    {
      path: '/user/:userId',
      component: User
    }
  ],
  //将URL hash模式改为History模式
  mode: 'history',
  // 将class重新命名为active 
  linkActiveClass: 'active'
})
```
```
//Home.vue

<template>
  <div>
    <h2>我是首页</h2>
    <p>我是首页的内容</p>

    <router-link to="/home/news">新闻</router-link>
    <router-link to="/home/message">消息</router-link>

    <router-view></router-view>
  </div>
</template>

<script>
export default {
  name: "Home",
};
</script>
 
<style scoped>
</style>
```
```
//App.vue

<template>
  <div id="app">
    <h2>我是APP组件</h2>
    <!-- <router-link to="/home" tag="button" replace>首页</router-link> -->
    <!-- <router-link to="/about" tag="button" replace>关于</router-link> -->
    <!-- <button @click="homeClick">首页</button> -->
    <!-- <button @click="aboutClick">关于</button> -->
    <router-link to="/home">首页</router-link>
    <router-link to="/about">关于</router-link>
    <router-link :to="'/user/' + userId">用户</router-link>

    <router-view></router-view>
  </div>
</template>

<script>
export default {
  name: "App",
  data() {
    return {
      userId: "Tom",
    };
  },
  methods: {
    homeClick() {
      // 通过代码的方式修改路径
      // this.$router.push('/home');
      this.$router.replace("/home");
      console.log("homeClick");
    },
    aboutClick() {
      // 通过代码的方式修改路径
      // this.$router.push('/about');
      this.$router.replace("/about");
      console.log("aboutClick");
    },
  },
};
</script>

<style>
.active {
  color: tomato;
}
</style>
```
### 18.10 `vue-router`参数传递
传递参数主要有两种类型：`params`和`query` <br/>
- `params`
  - 配置路由格式： /router/:id
  - 传递的方式：在path后面跟上对应的值
  - 传递后形成的路径：/router/123，/router/124
```
// 配置路由格式

export default new Router({
  // 配置路由和组件之间的映射关系 
  routes: [
    {
      path: '/user/:userId',
      component: User
    }
  ],
```
```
//传递方式
<router-link :to="'/user/' + userId">用户</router-link>
```
```
// 显示

<template>
  <div>
    <h2>我是用户界面</h2>
    <p>我是用户信息</p>
    <!-- 第一种方式：在网页中显示userId -->
    <h2>{{ userId }}</h2>
    <!-- 第二种方式：在网页中显示userId -->
    <h2>{{ $route.params.userId }}</h2>
  </div>
</template>

<script>
export default {
  name: "User",
  computed: {
    userId() {
      // 处于当前活跃状态的route
      return this.$route.params.userId;
    },
  },
};
</script>
<style scoped>
</style>
```
- `query`的类型
  - 配置路由格式：`/router`,也就是普通配置
  - 传递的方式：对象中使用`query`的`key`作为传递的方式
  - 传递后形成的路径：`/router?id=123`,`/router?id=abc`
```
//Profile.vue

<template>
  <div>
    <h2>我是Profile组件</h2>
    <p>我是Profile的内容</p>
    <h3>{{ $route.query.name }}</h3>
    <h3>{{ $route.query.age }}</h3>
    <h3>{{ $route.query.gender }}</h3>
  </div>
</template>

<script>
export default {
  name: "Profile",
};
</script>

<style scoped>
</style>
```
```
//index.js

import Vue from 'vue'
// 配置路由相关信息
import Router from 'vue-router'

// 导入要使用的组件
// import Home from '../components/Home'
// import About from '../components/About' 
// import User from '../components/User'

// 路由懒加载
const Home = () => import('../components/Home')
const HomeNews = () => import('../components/HomeNews')
const HomeMessage = () => import('../components/HomeMessage')
const About = () => import('../components/About')
const User = () => import('../components/User')
const Profile = () => import('../components/Profile')

// 1. 通过Vue.use(插件)，安装插件
Vue.use(Router)

// 2. 创建VueRouter对象
export default new Router({
  // 配置路由和组件之间的映射关系 
  routes: [
    {
      //redirect：重定向
      path: '',
      redirect: '/home',
    },
    {
      path: '/home',
      component: Home,
      children: [
        {
          path: '',
          redirect: 'news'
        },
        {
          path: 'news',
          component: HomeNews
        },
        {
          path: 'message',
          component: HomeMessage
        }
      ]
    },
    {
      path: '/about',
      component: About
    },
    {
      path: '/user/:userId',
      component: User
    },
    {
      path: '/profile',
      component: Profile
    }
  ],
  //将URL hash模式改为History模式
  mode: 'history',
  // 将class重新命名为active 
  linkActiveClass: 'active'
})
```
```
//App.vue

<template>
  <div id="app">
    <h2>我是APP组件</h2>
    <!-- <router-link to="/home" tag="button" replace>首页</router-link> -->
    <!-- <router-link to="/about" tag="button" replace>关于</router-link> -->
    <!-- <button @click="homeClick">首页</button> -->
    <!-- <button @click="aboutClick">关于</button> -->
    <router-link to="/home">首页</router-link>
    <router-link to="/about">关于</router-link>
    <!-- 往URL中添加userId -->
    <!-- <router-link :to="'/user/' + userId">用户</router-link> -->
    <!-- <router-link to ="/profile">档案</router-link> -->
    <!-- 往profile页面中添加内容 -->
    <!-- <router-link
      :to="{
        path: '/profile',
        query: { name: '孙悟空', age: 18, gender: '男' },
      }"
      >档案</router-link
    > -->

    <button @click="useClick">用户</button>
    <button @click="profileClick">档案</button>

    <router-view></router-view>
  </div>
</template>

<script>
export default {
  name: "App",
  data() {
    return {
      userId: "Tom",
    };
  },
  methods: {
    homeClick() {
      // 通过代码的方式修改路径
      // this.$router.push('/home');
      this.$router.replace("/home");
      console.log("homeClick");
    },
    aboutClick() {
      // 通过代码的方式修改路径
      // this.$router.push('/about');
      this.$router.replace("/about");
      console.log("aboutClick");
    },
    useClick() {
      this.$router.push("/user/" + this.userId);
      console.log("useClick");
    },
    profileClick() {
      this.$router.push({
        path: "/profile",
        query: { name: "孙悟空", age: 18, gender: "男" },
      });
      console.log("profileClick");
    },
  },
};
</script>

<style>
.active {
  color: tomato;
}
</style>
```
### 18.11 `router`和`route`的由来(没听懂)
- `router`：为`VueRouter`实例，想要导航到不同`URL`，则使用`$router.push`方法
- `route`：为当前`router`跳转对象里面可以获取`name`，`path`，`query`，`params`等
### 18.12 全局导航守卫
- 在一个SPA应用中，如何改变网页的标题呢？
  - 网页的标题是通过`<title>`来显示的，但是SPA只有一个固定的HTML，切换不同的页面时，标题并不会改变
  - 但是我们可以通过JavaScript来修改`<title>`的内容`.window.document.title = '新的标题'`
  - 那么在Vue项目中，在哪里修改？什么时候修改比较合适呢？
- 普通的修改方式
  - 我们比较容易想到的修改标题的位置是每一个路由对应的组件`.vue`文件中
  - 通过`mounted`声明周期函数，执行对应的代码进行修改即可
  - 但是当页面比较多时，这种方式不容易维护(因为需要在多个页面执行类似的代码)
- 有没有更好的办法呢？使用导航守卫即可
- 什么是导航守卫？
  - `vue-router`提供的导航守卫主要用来监听路由的进入和离开的
  - `vue-router`提供了`beforeEach`和`afterEach`的钩子函数，它们会在路由即将改变前和改变后触发
```
// 在SPA中，改变网页的标题

import Vue from 'vue'
// 配置路由相关信息
import Router from 'vue-router'

// 导入要使用的组件
// import Home from '../components/Home'
// import About from '../components/About' 
// import User from '../components/User'

// 路由懒加载
const Home = () => import('../components/Home')
const HomeNews = () => import('../components/HomeNews')
const HomeMessage = () => import('../components/HomeMessage')
const About = () => import('../components/About')
const User = () => import('../components/User')
const Profile = () => import('../components/Profile')

// 1. 通过Vue.use(插件)，安装插件
Vue.use(Router)

// 2. 创建VueRouter对象
const router = new Router({
  // 配置路由和组件之间的映射关系 
  routes: [
    {
      //redirect：重定向
      path: '',
      redirect: '/home',
    },
    {
      path: '/home',
      component: Home,
      // 给网页添加标题
      meta: {
        title: '首页'
      },
      children: [
        {
          path: '',
          redirect: 'news'
        },
        {
          path: 'news',
          component: HomeNews
        },
        {
          path: 'message',
          component: HomeMessage
        }
      ]
    },
    {
      path: '/about',
      component: About,
      meta: {
        title: '关于'
      },
    },
    {
      path: '/user/:userId',
      component: User,
      meta: {
        title: '用户'
      },
    },
    {
      path: '/profile',
      component: Profile,
      meta: {
        title: '档案'
      },
    }
  ],
  //将URL hash模式改为History模式
  mode: 'history',
  // 将class重新命名为active 
  linkActiveClass: 'active',
})

// 全局导航守卫：改变网页的标题
// 前置钩子或叫前置守卫
router.beforeEach((to, from, next) => {
  // 从from跳转到to
  document.title = to.matched[0].meta.title
  console.log(to)
  next()
})

// 3.将router对象传入到Vue实例
export default router
```
- 导航守卫的补充
 - `meta` ：元数据(描述数据的数据)
 - `beforeEach`：前置钩子(hook)
 - `afterEach`：后置钩子，不需要主动调用`next()`函数
 - `beforeEach`和`afterEach`被称之为全局守卫
   - 路由独享的守卫：`beforeEnter:(to, from, next) => {next()}`
   - 组件内的守卫：`beforeRouteEnter:(to,from,next){}`
### 18.13 `keep-alive`及其他问题
- `keep-alive`是`Vue`内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染
  - `include`：字符串或正则表达，只有匹配的组件会被缓存
  - `exclude`：字符串或正则表达，任何匹配的组件都不会被缓存
- `router-view`也是一个组件，如果直接被包在`keep-alive`里面，所以路径匹配到的视图组件都会被缓存
- `activated`和`destroyed`这两个函数，只有使用`keep-alive`时，才是有效的
```
//App.vue

<template>
  <div id="app">
    <h2>我是APP组件</h2>
    <!-- <router-link to="/home" tag="button" replace>首页</router-link> -->
    <!-- <router-link to="/about" tag="button" replace>关于</router-link> -->
    <!-- <button @click="homeClick">首页</button> -->
    <!-- <button @click="aboutClick">关于</button> -->
    <router-link to="/home">首页</router-link>
    <router-link to="/about">关于</router-link>
    <!-- 往URL中添加userId -->
    <!-- <router-link :to="'/user/' + userId">用户</router-link> -->
    <!-- <router-link to ="/profile">档案</router-link> -->
    <!-- 往profile页面中添加内容 -->
    <!-- <router-link
      :to="{
        path: '/profile',
        query: { name: '孙悟空', age: 18, gender: '男' },
      }"
      >档案</router-link
    > -->

    <button @click="useClick">用户</button>
    <button @click="profileClick">档案</button>

    //使被包含的组件保留状态，或避免重新渲染。除了User和Profile
    <keep-alive exclude="User,Profile"><router-view></router-view></keep-alive>
  </div>
</template>

<script>
export default {
  name: "App",
  data() {
    return {
      userId: "Tom",
    };
  },
  methods: {
    homeClick() {
      // 通过代码的方式修改路径
      // this.$router.push('/home');
      this.$router.replace("/home");
      console.log("homeClick");
    },
    aboutClick() {
      // 通过代码的方式修改路径
      // this.$router.push('/about');
      this.$router.replace("/about");
      console.log("aboutClick");
    },
    useClick() {
      this.$router.push("/user/" + this.userId);
      console.log("useClick");
    },
    profileClick() {
      this.$router.push({
        path: "/profile",
        query: { name: "孙悟空", age: 18, gender: "男" },
      });
      console.log("profileClick");
    },
  },
};
</script>

<style>
.active {
  color: tomato;
}
</style>
```
```
//Home.vue

<template>
  <div>
    <h2>我是首页</h2>
    <p>我是首页的内容</p>

    <router-link to="/home/news">新闻</router-link>
    <router-link to="/home/message">消息</router-link>

    <router-view></router-view>
  </div>
</template>

<script>
export default {
  name: "Home",
  // created() {
  //   document.title = "首页";
  // },
  created() {
    console.log("home created");
  },
  destroyed() {
    console.log("home destroyed");
  },
  // activated和destroyed这两个函数，只有使用keep-alive时，才是有效的
  activated() {
    this.$router.push(this.path);
  },
  beforeRouteLeave(to, from, next) {
    console.log(this.$route.path);
    this.path = this.$route.path;
    next();
  },
};
</script>
 
<style scoped>
</style>
```
## 19. `tabbar`
### 19.1 `tabbar`实现思路
1. 如果在下方有一个单独的`TabBar`组件，你如何封装？
  - 自定义`TabBar`组件，在`App`中使用
  - 让`TabBar`出于底部，并且设置相关的样式
2. `TabBar`中显示的内容由外界决定
  - 定义插槽
  - `flex`布局平分`TabBar`
3. 自定义`TabBarItem`，可以传入图片和文字
  - 定义`TabBarItem`，并且定义两个插槽：图片，文字
  - 给两个插槽外层包装`div`，用于设置样式
  - 填充插槽，实现底部`TabBar`的效果
### 19.2 `tabbar`练习
参考以下路径的代码：<br/>
`HelloWorld/Vuejs/03-tabbar/tabbar`
### 19.3 `tabbar`文件路径的引用问题
可以通过设置配置文件来解决繁琐的相对路径问题：<br/>
`build/webpack.base.conf.js`<br/>
```
//通过起别名的形式，来解决繁琐的相对路径问题
//将src路径命名为@
//将src/assets路径命名为assets
//将src/components路径命名为components
//将src/views路径命名为views

  resolve: {
    extensions: ['.js', '.vue', '.json'],
    alias: {
      '@': resolve('src'),
      'assets': resolve('src/assets'),
      'components': resolve('src/components'),
      'views': resolve('src/views')
    }
  },
```
## 20. `Promise`
### 20.1 介绍和基本使用
- ES6中一个非常重要和特别好用的特性就是`Promise`
- `Promise`到底是做什么的呢？
  - `Promise`是异步编程的一种解决方案
- 那什么时候我们会来处理异步事件呢？
  - 一种很常见的场景应该就是网络请求了
  - 我们封装一个网络请求的函数，因为不能立即拿到结果，所以不能像简单的3+4=7一样将结果返回
  - 所以往往我们会传入另外一个函数，在数据请求成功时，将数据通过传入的函数回调出去
  - 如果只是一个简单的网络请求，那么这种方案不会给我们带来很大的麻烦
- 但是，当网络请求非常复杂时，就会出现回调地狱
- 什么情况下会用到`Promise`？
  - 一般情况下是有异步操作时，使用`Promise`对这个异步操作进行封装
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // new -> 构造函数(1.保存一些状态信息 2.执行传入的函数)
        // 在执行传入的回调函数时，会传入两个参数：resolve，reject
        // resolve，reject又都是函数

        new Promise((resolve, reject) => {
            setTimeout(() => {
                // 成功的时候调用resolve
                resolve('Hello World')

                // 失败的时候调用reject
                reject('error message')
            }, 1000)
        }).then((data) => { //成功的时候，调用then函数。data就是传入的Hello World
            console.log(data)
        }).catch((err) => {
            console.log(err) //失败的时候，调用catch函数。err就是传入的error message
        })
    </script>
</body>
</html>
```
### 20.2 三种状态和另外处理方式
首先，当我们开发中有异步操作时，就可以给异步操作包装一个`Promise`。<br/>
异步操作之后会有三种状态：<br>
- `pending`：等待状态，比如正在进行网络请求，或者定时器没有到时间
- `fulfill`：满足状态，当我们主动回调了`resolve`时，就处于该状态，并且会回调`.then()`
- `reject`：拒绝状态，当我们主动回调了`reject`时，就处于该状态，并且会回调`.catch()`
### 20.3 链式调用
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 网络请求：aaa -> 自己处理(10行)
        // 处理：aaa111 -> 自己处理(10行)
        // 处理：aaa111222 -> 自己处理

        //第一种实现方式
        /*
        new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('aaa')
            }, 1000)
        }).then(res => {
            // 1. 自己处理10行代码
            console.log(res, '第一层的10行处理代码');

            // 对结果进行第一次处理
            return new Promise(resolve => {
                resolve(res + '111')
            })
        }).then(res => {
            console.log(res, '第二层的10行处理代码');

            return new Promise(resolve => {
                resolve(res + '222')
            })
        }).then(res => {
            console.log(res, '第三层的10行处理代码')
        })
        */

        //第二种实现方式
        /*
        new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('aaa')
            }, 1000)
        }).then(res => {
            console.log(res, '第一层的10行处理代码')

            return Promise.resolve(res + '111')
        }).then(res => {
            console.log(res, '第二层的10行处理代码')

            return Promise.resolve(res + '222')
        }).then(res => {
            console.log(res, '第三层的10行处理代码')
        })
        */

        // 第三种实现方式
        /*
        new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('aaa')
            }, 1000)
        }).then(res => {
            console.log(res, '第一层的10行处理代码')

            return res + '111'
        }).then(res => {
            console.log(res, '第二层的10行处理代码')

            return res + '222'
        }).then(res => {
            console.log(res, '第三层的10行处理代码')
        })

        实行结果：
            aaa 第一层的10行处理代码
            aaa111 第二层的10行处理代码
            aaa111222 第三层的10行处理代码
        */

        //reject的使用
        // 方式一：直接把resolve改成reject
        /*
        new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('aaa')
            }, 1000)
        }).then(res => {
            console.log(res, '第一层的10行处理代码')

            return Promise.reject('error message')
        }).then(res => {
            console.log(res, '第二层的10行处理代码')

            return Promise.resolve(res + '222')
        }).then(res => {
            console.log(res, '第三层的10行处理代码')
        }).catch(err => {
            console.log(err)
        })
        
        实行结果：
            aaa 第一层的10行处理代码
            error message
        */

        // 方式二
        new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('aaa')
            }, 1000)
        }).then(res => {
            console.log(res, '第一层的10行处理代码')

            throw 'error message'
        }).then(res => {
            console.log(res, '第二层的10行处理代码')

            return Promise.resolve(res + '222')
        }).then(res => {
            console.log(res, '第三层的10行处理代码')
        }).catch(err => {
            console.log(err)
        })
        
        /*
        实行结果：
            aaa 第一层的10行处理代码
            error message
        */
    </script>
</body>
</html>
```
### 20.4 `all`方法使用
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
        Promise.all([
            new Promise((resolve, reject) => {
                $.ajax({
                    url: 'url1',
                    success: function (data) {
                        resolve(data)
                    }
                })
            }),
            new Promise((resolve, reject) => {
                $.ajax({
                    url: 'url2',
                    success: function (data) {
                        resolve(data)
                    }
                })
            })
        ]).then(results => {
            results[0]
            results[1]
        })
        */

        Promise.all([
            new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve({ name: '孙悟空', age: 18 })
                }, 2000)
            }),
            new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve({ name: '猪八戒', age: 28 })
                })
            })
        ]).then(results => {
            console.log(results)
        })
    </script>
</body>
</html>

实行结果：

0: {name: "孙悟空", age: 18}
1: {name: "猪八戒", age: 28}
```
## 21. `Vuex`
### 21.1 `Vuex`概念和作用解析
### 21.2 单界面到多界面状态管理切换
### 21.3 `devtools`和`mutations`
### 21.4 `state`单一状态数的理解
### 21.5 `getter`的使用详解
### 21.6 `mutations`的携带参数
### 21.7 `mutations`的提交风格
### 21.8 数据的响应式原理
### 21.9 `mutations`的类型常量
### 21.10 `actions`的使用详解
### 21.11 `modules`的使用详解
### 21.12 `store`文件夹的目录组织

## 22. `axios`
### 22.1 网络请求模块的选择-`axios`
### 22.2 `axios`框架的基本使用
### 22.3 `axios`发送并发请求
### 22.4 `axios`的配置信息相关
### 22.5 `axios`的实例和模块封装
### 22.6 `axios`的拦截器的使用
 

