# Node.Js
## 1. 简介
- Node.js是一个能够在服务器端运行JavaScript的开放源代码，跨平台JavaScript运行环境
- Node.js采用Google开发的V8引擎运行js代码，使用事件驱动，非阻塞和异步I/O模型等技术来提高性能，可优化应用程序的传输量和规模
- Node大部分基本模块都用JavaScript编写。在Node出现之前，JS通常作为客户端程序设计语言使用，以JS写出的程序常在用户的浏览器上运行
- 目前，Node被IBM，Microsoft，Yahoo！，Walmart，Groupon，SAP，LinkdIn，Rakuten，Paypal，Voxer和GoDaddy等企业采用
- Node的服务器是单线程的
  - Node处理请求时是单线程，但是在后台拥有一个I/O线程池
## 2. 模块化
### 2.1 简介
#### 2.1.1 使用缘由
- ECMAScript标准的缺陷
  - 没有模块系统
  - 标准库较少
  - 没有标准接口
  - 缺乏管理系统
- 模块化
  - 如果程序设计的规模达到了一定程度，则必须对其进行模块化
  - 模块化可以有多种形式，但至少应该提供能能够将代码分割为多个源文件的机制
  - CommonJS的模块功能可以帮我们解决该问题
- CommonJS规范
  - CommonJS规范的提出，主要是为了弥补当前JavaScript没有标准的缺陷
  - CommonJS规范为JS指定了一个美好的远景，希望JS能够在任何地方运行
  - CommonJS对模块的定义十分简单
    - 模块引用
    - 模块定义
    - 模块标识
#### 2.1.2 模块定义和引用
- 在Node中，一个js文件就是一个模块
- 在Node中，每一个js文件中的js代码都是独立运行在一个函数中的
  - 而不是全局作用域，所以一个模块中的变量和函数在其他模块中无法访问
  - 此时我们可以通过`exports`来向外部暴露变量和方法
  - 只需要将需要暴露给外部的变量或方法设置为`exports`的属性即可
```
// 02_module.js

console.log("我是一个模块，我是02.module.js");

exports.x = "我是02.module.js中的x";
exports.y = "我是02.module.js中的y";
exports.fn = function () {
    console.log("我是02.module.js中的函数fn");
}
```
- 在Node中，通过`require()`方法引入外部的模块
  - `require()`可以传递一个文件的路径作为参数，Node将会自动根据该路径来引入外部模块
  - 这里的路径，如果使用相对路径，必须以`.`或`..`开头 
- 使用`require()`引入模块以后，该函数会返回一个对象，这个对象代表的是引入的模块
```
// 03_module.js

// 引入02_module.js模块
var md = require("./02_module");

console.log(md.x);
console.log(md.y);
md.fn();

实行结果：
 
我是一个模块，我是02.module.js
我是02.module.js中的x
我是02.module.js中的y
我是02.module.js中的函数fn
```
#### 2.1.3 模块标示
- 模块标识其实就是模块的名字，也就是传递给`require()`方法的参数
- 它必须是符合驼峰命名法的字符串，或者是以`.`,`..`开头的相对路径，或者绝对路径
- 模块的定义十分简单，接口也十分简洁
- 每个模块具有独立的空间它们互不干扰，在引用时也显得干净利落
- 模块分为两大类
  - 核心模块
    - 由node引擎提供的模块
    - 核心模块的标识就是模块的名字
    - `var fs = require("fs");` 
  - 文件模块
    - 由用户自己创建的模块
    - 文件模块的标识就是文件的路径(绝对路径或者相对路径)
      - 相对路径使用`.`或`..`开头
### 2.2 详解
#### 2.2.1 模块化的本质
- 在node中有一个全局对象`global`，它的作用和网页中`window`类似
  - 在全局中创建的变量都会作为`global`的属性保存
  - 在全局中创建的函数都会作为`global`的方法保存
```
var a = 10; //局部变量
console.log(global.a);

b = 20; //全局变量
console.log(global.b);

实行结果：
undefined
20
```
- 当`node`在执行模块中的代码时，它会首先在代码的最顶部，添加如下代码
```
function (exports, require, module, __filename, __dirname) {
```
- 在代码的最底部添加如下代码
``` 
}
```
- 实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进了5个实参
  - `exports`
    - 该对象用来将变量或函数暴露到外部
  - `require`
    - 函数，用来引入外部的模块
  - `module`
    - `module`代表的是当前模块本身
    - `exports`就是`module`的属性
    - 所以，既可以使用`exports`导出，也可以使用`module.exports`导出
    - `console.log(module.exports == exports); //true` 
  - `__filename`
    - 当前模块的完整路径
    - 比如：`console.log(__filename)`
    - 实行结果：`/Users/leo/IdeaProjects/HelloWorld/Nodejs/01-node/05_module.js`
  - `__dirname`
    - 当前模块所在文件夹的完整路径
    - 比如：`/Users/leo/IdeaProjects/HelloWorld/Nodejs/01-node`
- 证明模块中的代码都是包装在一个函数中执行：`arguments.callee`
  - 这个属性保存的是当前执行的函数对象
```
console.log(arguments.callee + "");

实行结果：
function (exports, require, module, __filename, __dirname) {
 
console.log(arguments.callee + "");

}
```
#### 2.2.2 `exports`和`module.exports` 
- 通过`exports`只能使用`.`的方式向外暴露内部变量
  - `exports.xxx = xxx;`
```
exports.name = "孙悟空";
exports.age = 18;
exports.sayName = function () {
    console.log("我是孙悟空");
}
```
- 而`module.exports`既可以通过`.`的形式，也可以直接赋值
  - `module.exports.xxx = xxx;`
  - `module.exports = {};`
```
module.exports.name = "孙悟空";
module.exports.age = 18;
module.exports.sayName = function () {
    console.log("我是孙悟空");
}
```
```
module.exports = {
    name: "孙悟空",
    age: 18,
    sayName: function () {
        console.log("我是孙悟空");
    }
}
```
## 3. 包 `package`
### 3.1 简介
- CommonJS的包规范允许我们将一组相关的模块组合到一起，形成一组完整的工具
- CommonJS的包规范由包结构和包描述文件两个部分组成
- 包结构
  - 用于组织包中的各个文件
- 包描述文件
  - 描述包的相关信息，以供外部读取分析
### 3.2 包结构
包实际上就是一个压缩文件，解压以后还原为目录。符合规范的目录，应该包含如下文件：<br/>
- `package.json`：描述文件(必须)
- `bin`：可执行二进制文件
- `lib`：js代码
- `doc`：文档
- `test`：单元测试
### 3.3 包描述文件
- 包描述文件用于表达非代码相关的信息
- 它是一个JSON格式的文件：`package.json`
- 位于包的根目录下，是包的重要组成部分
- `package.json`中的字段
  - `name`
  - `description`
  - `version`
  - `keywords`
  - `maintainers`
  - `contributors`
  - `bugs`
  - `licenses`
  - `repositories`
  - `dependencies`
  - `homepage`
  - `os`
  - `cpu`
  - `engine`
  - `builtin`
  - `directories`
  - `implements`
  - `scripts`
  - `author`
  - `bin`
  - `main`
  - `devDependencies`
- 注意：json文件里不能写注释
## 4. NPM(Node Package Manager)
### 4.1 简介
- CommonJS包规范是理论，NPM是其中一种实践
- 对于Node而言，NPM帮助其完成了第三方模块的发布，安装和依赖等
- 借助NPM，Node与第三方模块之间形成了很好的一个生态系统
- NPM命令
  - `npm -v`：查看`npm`版本
  - `npm version`：查看所有模块的版本
  - `npm`：帮助说明
  - `npm search 包名`：搜索模块包
    - 比如：`npm search math`
  - `npm install 包名`：在当前目录安装包
    - 比如：`npm install math`
  - `npm remove 包名`：删除一个模块
    - 比如：`npm remove math`
  - `npm install 包名 --save`：安装包并添加到依赖中
    - 即将安装包的信息添加到`pakage.json`中的`dependencies`
    - 比如：`"dependencies": {"vue": "^2.6.12"}`
  - `npm install`：下载当前项目所依赖的包
    - 将代码上传到`git`时，不会传`node_modules`，因为占空间很大而且版本会不断更新。
    - 所以上传到`git`时，只会上传代码和`pakage.json`。
    - 此时，其他用户可以通过`pakage.json`，下载当前项目所依赖的包。
  - `npm install 包名 -g`：全局模式安装包
    - 全局安装的包一般都是一些工具
  - `npm install 文件路径`：从本地安装
  - `npm install 包名 -registry=地址`：从镜像源安装
  - `npm config set registry 地址`：设置镜像源
### 4.2 配置CNPM 
- 淘宝NPM镜像：<https://developer.aliyun.com/mirror/NPM>
- 安装CNPM
```
npm install -g cnpm --registry=https://registry.npm.taobao.org
```
### 4.3 node搜索包的流程
- 通过`npm`下载的包都放到`node_modules`文件夹中
  - 我们通过`npm`下载的包，直接通过包名引入即可
```
var math = require("math");
console.log(math.add(123,456));

实行结果：
579

var express = require("express");
```
- `node`在使用模块名字来引入模块时，它会首先在当前目录的`node_modules`中寻找是否含有该模块
  - 如果有，则直接使用。如果没有，则去上一级目录的`node_modules`中寻找
  - 如果有，则直接使用。如果没有，则再去上一级目录寻找，直到找到为止
  - 直到找到磁盘的根目录，如果依然没有，则报错
## 5. `Buffer`缓冲区
### 5.1 简介
- `Buffer`的结构和数组很像，操作方法也和数组类似。
- 数组中不能存储二进制的文件，而`Buffer`就是专门用来存储二进制数据
- 使用`Buffer`不需要引入模块，直接使用即可
- 在`Buffer`中存储的都是二进制数据，但是在显示时都是以16进制的形式显示
  - `Buffer`中的每一个元素的范围是从`00 - ff`，`0  - 255`
  - 计算机中，一个0或一个1，称为1bit
  - `8bit =  1byte(字节)` `00000000 - 11111111`
  - `1024byte = 1kb`
  - `1024kb = 1mb`
  - `1024mb = 1gb`
  - `1024gb = 1tb`
  - `Buffer`中的一个元素，占用内存的一个字节
  - 注意：一个汉字占用三个字节
- 实际上`Buffer`中的内存不是通过`JavaScript`分配的，而是在底层通过`C++`申请的
- 也就是我们可以直接通过`Buffer`来创建内存中的空间
- `Buffer`的大小一旦确定，则不能修改
- `Buffer`实际上是对底层内存的直接操作
- 只要数字在控制台或页面中输出一定是10进制
### 5.2 方法
- `Buffer.from(str)` ：将一个字符串转换为buffer
```
var str = "Hello buffer";

// 将一个字符串保存到buffer中
var buf = Buffer.from(str);
console.log(buf);
console.log(buf.length); //占用内存的大小
console.log(str.length); //字符串的长度

实行结果：
<Buffer 48 65 6c 6c 6f 20 62 75 66 66 65 72>
12
12
```
- `Buffer.alloc(size)`：创建一个指定大小的`Buffer`
```
//创建一个指定大小的buffer
var buf = new Buffer.alloc(10); //创建10个字节的buffer
// 通过索引，来操作buf中的元素
buf[0] = 88;
buf[1] = 255;
buf[2] = 0xaa; //16进制以0x开头
buf[3] = 255;

console.log(buf); //<Buffer 58 ff aa ff 00 00 00 00 00 00>
console.log(buf.length); //10 
console.log(buf[2]); //只要数字在控制台或页面中输出一定是10进制 //170
console.log(buf[2].toString(16)); //转换成16进制 //aa
console.log(buf[2].toString(2)); //转换成2进制 //10101010

for (var i = 0; i < buf.length; i++) {
    console.log(buf[i]); //88 255 170 255 0 0 0 0 0 0
}
```
- `Buffer.allocUnsafe(size)`：创建一个指定大小的`Buffer`，但是`Buffer`中可能含有敏感数据
```
//比较Buffer.alloc(size)和Buffer.allocUnsafe(size)的区别
var buf2 = Buffer.alloc(10);
console.log(buf2); //清空内存中已有的数据

var buf3 = Buffer.allocUnsafe(10);
console.log(buf3); //保留之前的内存数据

实行结果：
<Buffer 00 00 00 00 00 00 00 00 00 00>
<Buffer b8 0e 81 06 01 00 00 00 6d c7>
```
- `buf.toString()`：将缓冲区中的数据转换为字符串
```
var buf = Buffer.from("我是一段文本数据");
console.log(buf.toString());

实行结果：
我是一段文本数据
```
- 其他方法参考官方网站：<http://nodejs.cn/api/buffer.html>
## 6. fs(文件系统)
### 6.1 简介
- 文件系统简单来说就是通过Node来操作系统中的文件
- 使用文件系统，需要先引入fs模块。fs是核心模块，直接引入不需要下载
```
var fs = require("fs");
```
### 6.2 同步和异步调用
- fs模块中所有的操作都有两种形式可供选择
  - 同步
    - 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码
  - 异步
    - 异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回
### 6.3 同步文件的写入
操作步骤：<br/>
- 打开文件
  - `fs.openSync(path[, flags, mode])`
    - `path`：要打开文件的路径
    - 
- 向文件中写入内容
- 保存并关闭文件
 


- 在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给远程的客户端
- Node通过fs模块来和文件系统进行交互
- 该模块提供了一些标准文件访问API来打开，读取，写入文件，以及与其交互
- 要使用fs模块，首先需要对其进行加载
  - `const fs = require("fs");` 






